use anyhow::{Context, Result};
use std::ffi::CString;
use tracing::{debug, info};
use wasmtime::*;
use wasmtime_wasi::{WasiCtxBuilder, WasiCtx};

pub struct WasmQualityFilter {
    engine: Engine,
    module: Module,
}

impl WasmQualityFilter {
    pub fn new(module_path: &str) -> Result<Self> {
        info!("ðŸ—ï¸ Initializing WASM runtime for module: {}", module_path);

        // Create WASM engine with optimizations
        let engine = Engine::new(
            Config::new()
                .wasm_backtrace_details(wasmtime::WasmBacktraceDetails::Enable)
                .debug_info(false) // Disable for production
        )?;

        // Load and compile the module
        let module_bytes = std::fs::read(module_path)
            .with_context(|| format!("Failed to read WASM module from {}", module_path))?;

        let module = Module::new(&engine, &module_bytes)
            .context("Failed to compile WASM module")?;

        info!("âœ… WASM module compiled successfully");

        Ok(Self { engine, module })
    }

    pub async fn process_message(&self, input: &str) -> Result<Option<String>> {
        debug!("ðŸ”„ Processing message through WASM module");

        // Create a new store for each invocation (thread-safe)
        let mut store = Store::new(
            &self.engine,
            WasiCtxBuilder::new()
                .inherit_stdio()
                .build(),
        );

        // Note: Fuel consumption not available in wasmtime 13.0

        // Create a linker and add WASI
        let mut linker = Linker::new(&self.engine);
        wasmtime_wasi::add_to_linker(&mut linker, |s| s)?;

        // Instantiate the module
        let instance = linker
            .instantiate(&mut store, &self.module)
            .context("Failed to instantiate WASM module")?;

        // Get the exported function
        let process_message_func = instance
            .get_typed_func::<(i32,), i32>(&mut store, "process_message")
            .context("Failed to get process_message function from WASM module")?;

        let free_string_func = instance
            .get_typed_func::<(i32,), ()>(&mut store, "free_string")
            .context("Failed to get free_string function from WASM module")?;

        // Get memory to pass data
        let memory = instance
            .get_memory(&mut store, "memory")
            .context("Failed to get WASM module memory")?;

        // Convert input string to C string
        let input_cstring = CString::new(input)
            .context("Failed to create C string from input")?;
        let input_bytes = input_cstring.as_bytes_with_nul();

        // Allocate memory in WASM
        let input_ptr = self.allocate_in_wasm(&mut store, &instance, input_bytes.len())?;

        // Write input data to WASM memory
        memory.write(&mut store, input_ptr, input_bytes)
            .context("Failed to write input to WASM memory")?;

        // Call the WASM function
        let result_ptr = process_message_func
            .call(&mut store, (input_ptr as i32,))
            .context("Failed to call WASM process_message function")?;

        // Free input memory
        self.free_in_wasm(&mut store, &instance, input_ptr, input_bytes.len())?;

        // Check if result is null (no alert generated)
        if result_ptr == 0 {
            debug!("No quality alert generated by WASM module");
            return Ok(None);
        }

        // Read result from WASM memory
        let result_string = self.read_string_from_wasm(&mut store, &memory, result_ptr as usize)?;

        // Free result memory in WASM
        free_string_func
            .call(&mut store, (result_ptr,))
            .context("Failed to free result string in WASM")?;

        debug!("âœ… WASM processing completed, alert generated");
        Ok(Some(result_string))
    }

    fn allocate_in_wasm(&self, store: &mut Store<WasiCtx>, instance: &Instance, size: usize) -> Result<usize> {
        // For simplicity, we'll use a fixed allocation strategy
        // In a production system, you might want to implement a proper allocator
        let memory = instance.get_memory(store, "memory")
            .context("Failed to get memory for allocation")?;
        
        let current_size = memory.size(store);
        let needed_pages = (size + 65535) / 65536; // Round up to pages
        
        if needed_pages > 0 {
            memory.grow(store, needed_pages as u64)
                .context("Failed to grow WASM memory")?;
        }
        
        // Return a pointer to the end of the previous memory
        Ok((current_size as usize) * 65536)
    }

    fn free_in_wasm(&self, _store: &mut Store<WasiCtx>, _instance: &Instance, _ptr: usize, _size: usize) -> Result<()> {
        // In a real implementation, you would track allocations and free them
        // For this demo, we'll just let the WASM instance be recreated each time
        Ok(())
    }

    fn read_string_from_wasm(&self, store: &mut Store<WasiCtx>, memory: &Memory, ptr: usize) -> Result<String> {
        // Read memory byte by byte until we find a null terminator
        let memory_data = memory.data(store);
        
        if ptr >= memory_data.len() {
            anyhow::bail!("Pointer out of bounds: {} >= {}", ptr, memory_data.len());
        }

        let mut end = ptr;
        while end < memory_data.len() && memory_data[end] != 0 {
            end += 1;
        }

        if end >= memory_data.len() {
            anyhow::bail!("No null terminator found for string at pointer {}", ptr);
        }

        let string_bytes = &memory_data[ptr..end];
        let result_string = String::from_utf8(string_bytes.to_vec())
            .context("Failed to convert WASM result to UTF-8 string")?;

        Ok(result_string)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::NamedTempFile;

    #[tokio::test]
    async fn test_wasm_filter_initialization() {
        // This test would require a valid WASM module file
        // For now, we'll just test that the struct can be created
        assert!(true); // Placeholder test
    }

    #[tokio::test]
    async fn test_message_processing() {
        // This would test actual message processing with a real WASM module
        // For now, we'll just test the structure
        assert!(true); // Placeholder test
    }
}