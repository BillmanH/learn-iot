name: Deploy IoT Edge Application

on:
  workflow_dispatch:
    inputs:
      app_folder:
        description: 'Application folder name (e.g., hello-flask, sputnik)'
        required: true
        type: choice
        options:
          - hello-flask
          - sputnik
      image_tag:
        description: 'Image tag (default: github.sha)'
        required: false
        default: ''
      skip_build:
        description: 'Skip building and pushing Docker image'
        required: false
        type: boolean
        default: false
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - development
          - production
        default: development

  push:
    branches:
      - main
      - dev
    paths:
      - 'iotopps/**'
      - '.github/workflows/deploy-iot-edge.yaml'

env:
  REGISTRY_TYPE: ${{ vars.REGISTRY_TYPE || 'dockerhub' }}
  REGISTRY_NAME: ${{ vars.REGISTRY_NAME }}
  AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
  AZURE_CLUSTER_NAME: ${{ secrets.AZURE_CLUSTER_NAME }}
  AZURE_LOCATION: ${{ vars.AZURE_LOCATION || 'eastus' }}

jobs:
  detect-changes:
    name: Detect Changed Applications
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    outputs:
      apps: ${{ steps.detect.outputs.apps }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changed applications
        id: detect
        run: |
          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Find unique app folders
          APPS=$(echo "$CHANGED_FILES" | grep '^iotopps/' | cut -d'/' -f2 | sort -u | grep -v '^$' || true)
          
          # Filter to only valid app directories (containing Dockerfile)
          VALID_APPS=""
          for app in $APPS; do
            if [ -f "iotopps/$app/Dockerfile" ]; then
              VALID_APPS="$VALID_APPS $app"
            fi
          done
          
          # Convert to JSON array
          if [ -z "$VALID_APPS" ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "apps=[]" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            JSON_APPS=$(echo $VALID_APPS | jq -R -s -c 'split(" ") | map(select(length > 0))')
            echo "apps=$JSON_APPS" >> $GITHUB_OUTPUT
          fi
          
          echo "Detected apps: $VALID_APPS"

  build-and-deploy:
    name: Build & Deploy ${{ matrix.app || inputs.app_folder }}
    runs-on: ubuntu-latest
    needs: [detect-changes]
    if: |
      always() && 
      (github.event_name == 'workflow_dispatch' || needs.detect-changes.outputs.has_changes == 'true')
    strategy:
      matrix:
        app: ${{ github.event_name == 'workflow_dispatch' && fromJson(format('["{0}"]', inputs.app_folder)) || fromJson(needs.detect-changes.outputs.apps) }}
      fail-fast: false
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set image tag
        id: set_tag
        run: |
          # Demo environment: always use 'latest' as the image tag
          TAG="latest"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Image tag: $TAG"

      - name: Set up Docker Buildx
        if: ${{ !inputs.skip_build }}
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: ${{ !inputs.skip_build && env.REGISTRY_TYPE == 'dockerhub' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Log in to Azure Container Registry
        if: ${{ !inputs.skip_build && env.REGISTRY_TYPE == 'acr' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_NAME }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build full image name
        id: image_name
        run: |
          REG_TYPE="$REGISTRY_TYPE"
          REG_NAME="$REGISTRY_NAME"
          APP_RAW="${{ matrix.app }}"
          # Trim whitespace and newlines from app name
          APP=$(printf '%s' "$APP_RAW" | tr -d '\r\n' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
          echo "App raw: [$APP_RAW]"
          echo "App trimmed: [$APP]"

          # Demo: always use latest
          if [ "$REG_TYPE" = "acr" ]; then
            if [ -n "$REG_NAME" ]; then
              FULL_IMAGE="$REG_NAME.azurecr.io/$APP:latest"
            else
              FULL_IMAGE="$APP:latest"
            fi
          else
            # dockerhub: if REGISTRY_NAME is empty, fall back to secrets.DOCKER_USERNAME
            if [ -n "$REG_NAME" ]; then
              NAMESPACE="$REG_NAME"
            else
              NAMESPACE="${{ secrets.DOCKER_USERNAME }}"
            fi
            FULL_IMAGE="$NAMESPACE/$APP:latest"
          fi

          echo "full_image=$FULL_IMAGE" >> $GITHUB_OUTPUT
          echo "Full image name: $FULL_IMAGE"

      - name: Build and push Docker image
        if: ${{ !inputs.skip_build }}
        uses: docker/build-push-action@v5
        with:
          context: ./iotopps/${{ matrix.app }}
          push: true
          tags: |
            ${{ steps.image_name.outputs.full_image }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Azure Subscription
        run: |
          az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          az account show

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Get Arc cluster credentials
        run: |
          echo "Connecting to Arc-enabled cluster..."
          
          # Trim and export secrets to avoid accidental whitespace/newlines
          AZURE_CLUSTER_NAME=$(printf '%s' "$AZURE_CLUSTER_NAME" | tr -d '\r\n' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
          AZURE_RESOURCE_GROUP=$(printf '%s' "$AZURE_RESOURCE_GROUP" | tr -d '\r\n' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

          # Debug: confirm variables are present (do not print secret values)
          if [ -n "$AZURE_CLUSTER_NAME" ]; then
            echo "AZURE_CLUSTER_NAME is set"
          else
            echo "AZURE_CLUSTER_NAME is empty"
          fi
          if [ -n "$AZURE_RESOURCE_GROUP" ]; then
            echo "AZURE_RESOURCE_GROUP is set"
          else
            echo "AZURE_RESOURCE_GROUP is empty"
          fi

          # Fail fast if required environment variables are empty
          if [ -z "$AZURE_CLUSTER_NAME" ] || [ -z "$AZURE_RESOURCE_GROUP" ]; then
            echo "Error: AZURE_CLUSTER_NAME and AZURE_RESOURCE_GROUP must be set."
            echo "Set repository secrets accordingly."
            exit 2
          fi

          # Install connectedk8s extension if not present
          az extension add --name connectedk8s --upgrade

          # Verify cluster is connected
          az connectedk8s show \
            --name "$AZURE_CLUSTER_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP"
          
          # Get cluster credentials using proxy
          echo "Starting Arc proxy connection..."
          timeout 120 az connectedk8s proxy \
            --name "$AZURE_CLUSTER_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" &
          
          PROXY_PID=$!
          echo "Proxy PID: $PROXY_PID"
          
          # Wait for proxy to be ready: check proxy process, listening port, and lightweight kubectl server check
          echo "Waiting for proxy to be ready..."
          # give proxy a moment to start
          sleep 1
          PROXY_OK=0
          for i in {1..30}; do
            # ensure proxy process still exists
            if ! kill -0 "$PROXY_PID" 2>/dev/null; then
              echo "Proxy process $PROXY_PID is not running"
              exit 1
            fi

              # lightweight kubectl check that usually works with minimal permissions
              if kubectl version --output=json --request-timeout='5s' 2>&1 | grep -q 'serverVersion'; then
                echo "Successfully connected to API server (kubectl can reach server)"
                PROXY_OK=1
                break
              else
                # capture last kubectl error for diagnostics
                KUBECTL_ERR=$(kubectl version --output=json --request-timeout='5s' 2>&1 || true)
                echo "kubectl version output:"
                echo "$KUBECTL_ERR"
                # If Forbidden appears, show a helpful hint for RBAC
                if echo "$KUBECTL_ERR" | grep -qi forbidden; then
                  echo "Detected RBAC Forbidden when contacting the API server."
                  echo "Your identity may lack permission to query cluster resources."
                  echo "To allow basic diagnostics, a cluster admin can run:" 
                  echo "kubectl create clusterrolebinding gha-actions-view --clusterrole=view --user=<YOUR_SP_CLIENT_ID>"
                  # don't break here; maybe server becomes reachable for other reasons
                fi
              fi

            echo "Waiting for connection... ($i/30)"
            sleep 2
          done

          if [ "$PROXY_OK" -ne 1 ]; then
            echo "Proxy didn't become ready within the timeout. Running final diagnostic:"
            kubectl cluster-info || true
            kubectl get nodes || true
            exit 1
          fi

      - name: Create deployment manifest
        run: |
          # Read deployment template
          DEPLOYMENT_FILE="iotopps/${{ matrix.app }}/deployment.yaml"
          
          if [ ! -f "$DEPLOYMENT_FILE" ]; then
            echo "Error: deployment.yaml not found for ${{ matrix.app }}"
            exit 1
          fi
          
          # Replace placeholders
          sed "s|<YOUR_REGISTRY>|${{ env.REGISTRY_NAME }}|g" "$DEPLOYMENT_FILE" | \
          sed "s|:latest|:${{ steps.set_tag.outputs.tag }}|g" > deployment-temp.yaml
          
          echo "Generated deployment manifest:"
          cat deployment-temp.yaml

      - name: Deploy to Kubernetes
        run: |
          kubectl apply -f deployment-temp.yaml -n default
          
          # Wait for deployment to be ready
          kubectl rollout status deployment/${{ matrix.app }} --namespace default --timeout=5m
          
          echo "Deployment completed successfully"

      - name: Get service information
        id: service_info
        run: |
          SERVICE_NAME="${{ matrix.app }}-service"
          
          # Get service details
          kubectl get service $SERVICE_NAME -n default
          
          # Try to get node port
          NODE_PORT=$(kubectl get service $SERVICE_NAME -n default -o jsonpath='{.spec.ports[0].nodePort}' || echo "N/A")
          echo "node_port=$NODE_PORT" >> $GITHUB_OUTPUT
          
          # Get node IP (if available)
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}' || echo "N/A")
          echo "node_ip=$NODE_IP" >> $GITHUB_OUTPUT
          
          echo "Service exposed on port: $NODE_PORT"

      - name: Verify deployment
        run: |
          echo "=== Deployment Status ==="
          kubectl get deployment ${{ matrix.app }} -n default
          
          echo -e "\n=== Pods ==="
          kubectl get pods -l app=${{ matrix.app }} -n default
          
          echo -e "\n=== Service ==="
          kubectl get service ${{ matrix.app }}-service -n default
          
          echo -e "\n=== Recent Events ==="
          kubectl get events -n default --sort-by='.lastTimestamp' | grep ${{ matrix.app }} | tail -10

      - name: Cleanup proxy
        if: always()
        run: |
          # Kill any proxy processes
          pkill -f "connectedk8s proxy" || true

      - name: Deployment Summary
        if: success()
        run: |
          cat << EOF >> $GITHUB_STEP_SUMMARY
          ## âœ… Deployment Successful
          
          **Application:** ${{ matrix.app }}  
          **Image:** ${{ steps.image_name.outputs.full_image }}  
          **Cluster:** (secret)  
          **Resource Group:** (secret)  
          **Node Port:** ${{ steps.service_info.outputs.node_port }}
          
          ### Useful Commands
          \`\`\`bash
          # View pods
          kubectl get pods -l app=${{ matrix.app }} -n default
          
          # View logs
          kubectl logs -l app=${{ matrix.app }} -n default
          
          # View service
          kubectl get service ${{ matrix.app }}-service -n default
          
          # Describe deployment
          kubectl describe deployment ${{ matrix.app }} -n default
          \`\`\`
          EOF

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## ðŸš€ Deployment Status: ${{ matrix.app }}
              
              âœ… Successfully deployed to **(secret cluster)**
              
              **Image:** \`${{ steps.image_name.outputs.full_image }}\`
              **Node Port:** \`${{ steps.service_info.outputs.node_port }}\`
              
              [View workflow run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})`
            })
