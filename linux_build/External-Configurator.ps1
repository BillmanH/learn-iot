<#
.SYNOPSIS
    Azure IoT Operations - External Configurator (PowerShell)

.DESCRIPTION
    This script connects edge K3s clusters to Azure Arc and deploys Azure IoT Operations.
    It runs on a Windows management machine with Azure CLI and handles all Azure resource creation.
    
    Requirements:
    - Windows 10/11 or Windows Server 2019+
    - PowerShell 5.1+ or PowerShell 7+
    - Azure CLI installed
    - Azure credentials with appropriate permissions
    - cluster_info.json from linux_installer.sh
    - Network connectivity to edge device (for kubectl commands)
    
.PARAMETER ClusterInfo
    Path to cluster_info.json file generated by linux_installer.sh
    
.PARAMETER ConfigFile
    Path to azure_config.json configuration file (default: azure_config.json)
    
.PARAMETER DryRun
    Validate configuration without making changes
    
.PARAMETER SkipArcEnable
    Skip Arc-enabling the cluster (useful if already Arc-enabled)
    
.PARAMETER SkipVerification
    Skip post-deployment verification

.PARAMETER UseArcProxy
    Use Azure Arc proxy for kubectl connectivity (for remote networks)
    Requires cluster to already be Arc-enabled

.PARAMETER SkipKeyVault
    Skip Azure Key Vault creation and configuration
    Use this if you don't need secret management for dataflows
    
.EXAMPLE
    .\External-Configurator.ps1 -ClusterInfo cluster_info.json
    
.EXAMPLE
    .\External-Configurator.ps1 -ClusterInfo cluster_info.json -ConfigFile linux_aio_config.json -DryRun
    
.NOTES
    Author: Azure IoT Operations Team
    Date: January 2026
    Version: 1.0.0 - External Configurator (Separation of Concerns)
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [string]$ClusterInfo = "cluster_info.json",
    
    [Parameter(Mandatory=$false)]
    [string]$ConfigFile = "",
    
    [Parameter(Mandatory=$false)]
    [switch]$DryRun,
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipArcEnable,
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipVerification,
    
    [Parameter(Mandatory=$false)]
    [switch]$UseArcProxy,
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipKeyVault
)

# ============================================================================
# GLOBAL VARIABLES
# ============================================================================

$script:ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$script:LogFile = Join-Path $script:ScriptDir "external_configurator_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
$script:DeploymentSummaryFile = Join-Path $script:ScriptDir "deployment_summary.json"

# Configuration variables (loaded from files)
$script:ClusterData = $null
$script:AzureConfig = $null
$script:SubscriptionId = $null
$script:SubscriptionName = $null
$script:ResourceGroup = $null
$script:Location = $null
$script:ClusterName = $null
$script:NamespaceName = $null
$script:DeployMqttAssets = $true
$script:EnableResourceSync = $true
$script:DeploymentMode = "production"
$script:KeyVaultName = $null
$script:CreateKeyVault = $true

# Deployment tracking
$script:DeployedResources = @()
$script:Errors = @()

# ============================================================================
# LOGGING FUNCTIONS
# ============================================================================

function Initialize-Logging {
    Start-Transcript -Path $script:LogFile -Append
    
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host "Azure IoT Operations - External Configurator" -ForegroundColor Cyan
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host "Log file: $script:LogFile" -ForegroundColor Gray
    Write-Host "Started: $(Get-Date)" -ForegroundColor Gray
    Write-Host "Script directory: $script:ScriptDir" -ForegroundColor Gray
    Write-Host ""
    
    if ($DryRun) {
        Write-Warning "RUNNING IN DRY-RUN MODE - No changes will be made"
        Write-Host ""
    }
}

function Write-Log {
    param([string]$Message)
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Host "[${timestamp}] $Message" -ForegroundColor Green
}

function Write-InfoLog {
    param([string]$Message)
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Host "[${timestamp}] INFO: $Message" -ForegroundColor Cyan
}

function Write-WarnLog {
    param([string]$Message)
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Warning "[${timestamp}] WARNING: $Message"
}

function Write-ErrorLog {
    param(
        [string]$Message,
        [switch]$Fatal
    )
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Host "[${timestamp}] ERROR: $Message" -ForegroundColor Red
    
    $script:Errors += $Message
    
    if ($Fatal) {
        Write-Host ""
        Write-Host "Fatal error encountered. Exiting." -ForegroundColor Red
        Write-Host "Check log file for details: $script:LogFile" -ForegroundColor Yellow
        Stop-Transcript
        exit 1
    }
}

function Write-Success {
    param([string]$Message)
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Host "[${timestamp}] SUCCESS: $Message" -ForegroundColor Green
}

# ============================================================================
# PREREQUISITE CHECKS
# ============================================================================

function Test-Prerequisites {
    Write-Log "Checking prerequisites..."
    
    $allPassed = $true
    
    # Check PowerShell version
    $psVersion = $PSVersionTable.PSVersion
    if ($psVersion.Major -lt 5) {
        Write-ErrorLog "PowerShell 5.1 or higher is required. Current version: $psVersion"
        $allPassed = $false
    } else {
        Write-Success "PowerShell version: $psVersion"
    }
    
    # Check if Azure CLI is installed
    try {
        $azVersion = az version --output json | ConvertFrom-Json
        Write-Success "Azure CLI version: $($azVersion.'azure-cli')"
    } catch {
        Write-ErrorLog "Azure CLI is not installed or not in PATH" -Fatal
    }
    
    # Check if kubectl is accessible
    try {
        $kubectlVersion = kubectl version --client --output=json 2>$null | ConvertFrom-Json
        Write-Success "kubectl version: $($kubectlVersion.clientVersion.gitVersion)"
    } catch {
        Write-WarnLog "kubectl not found. Will need to configure from cluster_info.json"
    }
    
    # Check if cluster_info.json exists
    if ([System.IO.Path]::IsPathRooted($ClusterInfo)) { 
        $clusterInfoPath = $ClusterInfo
    } else {
        # Check edge_configs folder first, then linux_build folder
        $searchPaths = @(
            (Join-Path $script:ScriptDir "edge_configs\$ClusterInfo"),
            (Join-Path $script:ScriptDir $ClusterInfo)
        )
        
        $clusterInfoPath = $null
        foreach ($path in $searchPaths) {
            if (Test-Path $path) {
                $clusterInfoPath = $path
                break
            }
        }
        
        if (-not $clusterInfoPath) {
            $clusterInfoPath = Join-Path $script:ScriptDir $ClusterInfo
        }
    }
    
    if (-not (Test-Path $clusterInfoPath)) {
        Write-ErrorLog "Cluster info file not found: $clusterInfoPath" -Fatal
    } else {
        Write-Success "Cluster info file found: $clusterInfoPath"
    }
    
    if (-not $allPassed) {
        Write-ErrorLog "Prerequisite checks failed" -Fatal
    }
    
    Write-Success "All prerequisites passed"
}

function Test-CSISecretStore {
    Write-Log "Checking for CSI Secret Store driver (required for Fabric RTI dataflows)..."
    
    try {
        # Check for CSI driver resource
        $csiDriver = kubectl get csidriver secrets-store.csi.k8s.io --ignore-not-found 2>&1
        
        if ($LASTEXITCODE -ne 0 -or [string]::IsNullOrEmpty($csiDriver)) {
            Write-WarnLog "CSI Secret Store driver not found"
            Write-Host ""
            Write-Host "WARNING: CSI Secret Store driver is NOT installed" -ForegroundColor Yellow
            Write-Host ""
            Write-Host "This means:" -ForegroundColor Yellow
            Write-Host "  [X] Secret management will NOT be available" -ForegroundColor Red
            Write-Host "  [X] Fabric Real-Time Intelligence dataflows will NOT work" -ForegroundColor Red
            Write-Host "  [X] Azure Key Vault integration will be disabled" -ForegroundColor Red
            Write-Host ""
            Write-Host "To fix this, run on your Linux edge device:" -ForegroundColor Cyan
            Write-Host ""
            Write-Host "  helm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts" -ForegroundColor White
            Write-Host "  helm repo add csi-secrets-store-provider-azure https://azure.github.io/secrets-store-csi-driver-provider-azure/charts" -ForegroundColor White
            Write-Host "  helm repo update" -ForegroundColor White
            Write-Host ""
            Write-Host "  helm install csi-secrets-store-driver secrets-store-csi-driver/secrets-store-csi-driver \" -ForegroundColor White
            Write-Host "      --namespace kube-system \" -ForegroundColor White
            Write-Host "      --set syncSecret.enabled=true \" -ForegroundColor White
            Write-Host "      --set enableSecretRotation=true" -ForegroundColor White
            Write-Host ""
            Write-Host "  helm install azure-csi-provider csi-secrets-store-provider-azure/csi-secrets-store-provider-azure \" -ForegroundColor White
            Write-Host "      --namespace kube-system" -ForegroundColor White
            Write-Host ""
            Write-Host "Or use the updated linux_installer.sh which includes CSI Secret Store installation." -ForegroundColor Cyan
            Write-Host ""
            Write-Host "See: linux_build\CSI_SECRET_STORE_SETUP.md for details" -ForegroundColor Gray
            Write-Host ""
            
            $continue = Read-Host "Continue without secret management? (y/N)"
            if ($continue -ne 'y' -and $continue -ne 'Y') {
                Write-ErrorLog "Deployment cancelled. Please install CSI Secret Store first." -Fatal
            }
            
            Write-WarnLog "Continuing without secret management - Fabric RTI will NOT be available"
            return $false
        }
        
        # Check for CSI driver pods
        $csiPods = kubectl get pods -n kube-system -l app.kubernetes.io/name=secrets-store-csi-driver --no-headers 2>&1
        $csiPodCount = if ($csiPods -is [array]) { $csiPods.Count } elseif ($csiPods) { 1 } else { 0 }
        
        # Check for Azure provider pods
        $azurePods = kubectl get pods -n kube-system -l app=csi-secrets-store-provider-azure --no-headers 2>&1
        $azurePodCount = if ($azurePods -is [array]) { $azurePods.Count } elseif ($azurePods) { 1 } else { 0 }
        
        if ($csiPodCount -gt 0 -and $azurePodCount -gt 0) {
            Write-Success "CSI Secret Store driver installed ($csiPodCount pod(s))"
            Write-Success "Azure Key Vault provider installed ($azurePodCount pod(s))"
            Write-InfoLog "Secret management is enabled - Fabric RTI dataflows will work"
            return $true
        } else {
            Write-WarnLog "CSI driver resource found but pods may not be ready"
            Write-WarnLog "  CSI driver pods: $csiPodCount"
            Write-WarnLog "  Azure provider pods: $azurePodCount"
            Write-WarnLog "Secret management may not work properly"
            return $false
        }
        
    } catch {
        Write-WarnLog "Could not verify CSI Secret Store: $_"
        Write-WarnLog "Secret management status unknown"
        return $false
    }
}

# ============================================================================
# CONFIGURATION LOADING
# ============================================================================

function Import-ClusterInfo {
    Write-Log "Loading cluster information..."
    
    $clusterInfoPath = $null
    
    if ([System.IO.Path]::IsPathRooted($ClusterInfo)) { 
        $clusterInfoPath = $ClusterInfo
    } else {
        # Check edge_configs folder first, then linux_build folder
        $searchPaths = @(
            (Join-Path $script:ScriptDir "edge_configs\$ClusterInfo"),
            (Join-Path $script:ScriptDir $ClusterInfo)
        )
        
        Write-InfoLog "Searching for cluster_info.json..."
        foreach ($path in $searchPaths) {
            Write-InfoLog "Checking: $path"
            if (Test-Path $path) {
                $clusterInfoPath = $path
                Write-Success "Found cluster info at: $path"
                break
            }
        }
        
        if (-not $clusterInfoPath) {
            Write-Host ""
            Write-ErrorLog "Cluster info file 'cluster_info.json' not found in expected locations:"
            foreach ($path in $searchPaths) {
                Write-Host "  - $path" -ForegroundColor Gray
            }
            Write-Host ""
            Write-Host "To generate cluster_info.json:" -ForegroundColor Yellow
            Write-Host "  1. Run linux_installer.sh on your edge device" -ForegroundColor Gray
            Write-Host "  2. Copy the generated cluster_info.json from the edge device" -ForegroundColor Gray
            Write-Host "  3. Place it in: $($searchPaths[0])" -ForegroundColor Gray
            Write-Host "     or: $($searchPaths[1])" -ForegroundColor Gray
            Write-Host ""
            Write-ErrorLog "cluster_info.json is required. Exiting." -Fatal
        }
    }
    
    if (-not (Test-Path $clusterInfoPath)) {
        Write-ErrorLog "Cluster info file not found: $clusterInfoPath" -Fatal
    }
    
    try {
        $script:ClusterData = Get-Content $clusterInfoPath -Raw | ConvertFrom-Json
        
        Write-Host ""
        Write-Host "Cluster Information:" -ForegroundColor Cyan
        Write-Host "  Cluster Name: $($script:ClusterData.cluster_name)" -ForegroundColor Gray
        Write-Host "  Node Name: $($script:ClusterData.node_name)" -ForegroundColor Gray
        Write-Host "  Kubernetes Version: $($script:ClusterData.kubernetes_version)" -ForegroundColor Gray
        Write-Host "  Node OS: $($script:ClusterData.node_os)" -ForegroundColor Gray
        Write-Host "  Timestamp: $($script:ClusterData.timestamp)" -ForegroundColor Gray
        Write-Host "  Ready for Arc: $($script:ClusterData.ready_for_arc)" -ForegroundColor Gray
        
        if ($script:ClusterData.deployed_modules -and $script:ClusterData.deployed_modules.Count -gt 0) {
            Write-Host "  Deployed Modules: $($script:ClusterData.deployed_modules -join ', ')" -ForegroundColor Gray
        }
        
        if ($script:ClusterData.installed_tools -and $script:ClusterData.installed_tools.Count -gt 0) {
            Write-Host "  Installed Tools: $($script:ClusterData.installed_tools -join ', ')" -ForegroundColor Gray
        }
        Write-Host ""
        
        # Set cluster name from cluster info
        $script:ClusterName = $script:ClusterData.cluster_name
        
        Write-Success "Cluster information loaded successfully"
    } catch {
        Write-ErrorLog "Failed to parse cluster info file: $_" -Fatal
    }
}

function Import-AzureConfig {
    $configPath = $null
    
    # If ConfigFile parameter is provided, use it
    if ($ConfigFile) {
        if ([System.IO.Path]::IsPathRooted($ConfigFile)) { 
            $configPath = $ConfigFile 
        } else { 
            $configPath = Join-Path $script:ScriptDir $ConfigFile 
        }
        
        if (-not (Test-Path $configPath)) {
            Write-ErrorLog "Specified config file not found: $configPath" -Fatal
        }
        
        Write-Log "Loading configuration from $configPath..."
    } else {
        # Search for linux_aio_config.json in expected locations
        $searchPaths = @(
            (Join-Path $script:ScriptDir "edge_configs\linux_aio_config.json"),
            (Join-Path $script:ScriptDir "linux_aio_config.json")
        )
        
        Write-Log "Searching for linux_aio_config.json..."
        
        foreach ($path in $searchPaths) {
            Write-InfoLog "Checking: $path"
            if (Test-Path $path) {
                $configPath = $path
                Write-Success "Found configuration at: $path"
                break
            }
        }
        
        if (-not $configPath) {
            Write-Host ""
            Write-WarnLog "Configuration file 'linux_aio_config.json' not found in expected locations:"
            foreach ($path in $searchPaths) {
                Write-Host "  - $path" -ForegroundColor Gray
            }
            Write-Host ""
            Write-Host "To use this configurator, you need to:" -ForegroundColor Yellow
            Write-Host "  1. Run linux_installer.sh on your edge device" -ForegroundColor Gray
            Write-Host "  2. Copy the generated linux_aio_config.json file from the edge device" -ForegroundColor Gray
            Write-Host "  3. Place it in one of these locations:" -ForegroundColor Gray
            Write-Host "     - $($searchPaths[0])" -ForegroundColor Gray
            Write-Host "     - $($searchPaths[1])" -ForegroundColor Gray
            Write-Host ""
            Write-Host "Alternatively, you can:" -ForegroundColor Yellow
            Write-Host "  - Specify a custom config file: -ConfigFile 'path\to\config.json'" -ForegroundColor Gray
            Write-Host "  - Continue in interactive mode (you will be prompted for values)" -ForegroundColor Gray
            Write-Host ""
            
            $continue = Read-Host "Continue in interactive mode? (y/n)"
            if ($continue -ne 'y') {
                Write-ErrorLog "Configuration file required. Exiting." -Fatal
            }
            
            Write-InfoLog "Using interactive configuration mode"
            return
        }
    }
    
    try {
        $script:AzureConfig = Get-Content $configPath -Raw | ConvertFrom-Json
        
        # Load Azure settings
        $script:SubscriptionId = $script:AzureConfig.azure.subscription_id
        $script:SubscriptionName = $script:AzureConfig.azure.subscription_name
        $script:ResourceGroup = $script:AzureConfig.azure.resource_group
        $script:Location = $script:AzureConfig.azure.location
        $script:NamespaceName = $script:AzureConfig.azure.namespace_name
        
        # Override cluster name from config if provided
        if ($script:AzureConfig.azure.cluster_name) {
            $script:ClusterName = $script:AzureConfig.azure.cluster_name
        }
        
        # Load deployment settings
        if ($script:AzureConfig.deployment) {
            $script:DeploymentMode = if ($script:AzureConfig.deployment.deployment_mode) { $script:AzureConfig.deployment.deployment_mode } else { "production" }
            $script:DeployMqttAssets = if ($null -ne $script:AzureConfig.deployment.deploy_mqtt_assets) { $script:AzureConfig.deployment.deploy_mqtt_assets } else { $true }
            $script:EnableResourceSync = if ($null -ne $script:AzureConfig.deployment.enable_resource_sync) { $script:AzureConfig.deployment.enable_resource_sync } else { $true }
        }
        
        # Load Key Vault settings (optional)
        if ($script:AzureConfig.azure.key_vault_name) {
            $script:KeyVaultName = $script:AzureConfig.azure.key_vault_name
        }
        
        Write-Success "Azure configuration loaded successfully"
    } catch {
        Write-ErrorLog "Failed to parse Azure config file: $_" -Fatal
    }
}

# ============================================================================
# AZURE AUTHENTICATION
# ============================================================================

function Connect-ToAzure {
    Write-Log "Checking Azure authentication..."
    
    # Check if already logged in
    try {
        $currentAccount = az account show 2>$null | ConvertFrom-Json
        if ($currentAccount) {
            Write-Success "Already logged into Azure"
            Write-InfoLog "Current subscription: $($currentAccount.name)"
            
            # Use current subscription if not specified in config
            if (-not $script:SubscriptionId) {
                $script:SubscriptionId = $currentAccount.id
                $script:SubscriptionName = $currentAccount.name
            }
        }
    } catch {
        Write-Log "Not currently logged into Azure. Initiating login..."
        
        if ($DryRun) {
            Write-InfoLog "[DRY-RUN] Would execute: az login"
            return
        }
        
        # Login to Azure
        az login
        
        # Get current subscription after login
        $currentAccount = az account show | ConvertFrom-Json
        if (-not $script:SubscriptionId) {
            $script:SubscriptionId = $currentAccount.id
            $script:SubscriptionName = $currentAccount.name
        }
    }
    
    # Set subscription if specified and different from current
    $currentSubId = (az account show | ConvertFrom-Json).id
    if ($script:SubscriptionId -and ($script:SubscriptionId -ne $currentSubId)) {
        Write-Log "Setting subscription to: $script:SubscriptionId"
        
        if ($DryRun) {
            Write-InfoLog "[DRY-RUN] Would execute: az account set --subscription $script:SubscriptionId"
        } else {
            az account set --subscription $script:SubscriptionId
        }
    }
    
    # Get final subscription details
    $currentAccount = az account show | ConvertFrom-Json
    $script:SubscriptionId = $currentAccount.id
    $script:SubscriptionName = $currentAccount.name
    
    # Prompt for missing configuration values (only if not loaded from config file)
    if (-not $script:ResourceGroup) {
        Write-Host ""
        Write-WarnLog "Resource group not specified in config file"
        Write-Host "  Config file should contain: azure.resource_group" -ForegroundColor Gray
        Write-Host ""
        $script:ResourceGroup = Read-Host "Enter resource group name (will be created if it does not exist)"
    }
    
    if (-not $script:Location) {
        Write-Host ""
        Write-WarnLog "Location not specified in config file"
        Write-Host "  Config file should contain: azure.location" -ForegroundColor Gray
        Write-Host ""
        $script:Location = Read-Host "Enter Azure region (e.g. eastus or westus2 or westeurope)"
    }
    
    if (-not $script:NamespaceName) {
        Write-Host ""
        Write-WarnLog "Namespace name not specified in config file"
        Write-Host "  Config file should contain: azure.namespace_name" -ForegroundColor Gray
        Write-Host ""
        $script:NamespaceName = Read-Host "Enter namespace name for Azure Device Registry"
    }
    
    Write-Host ""
    Write-Host "Azure Configuration:" -ForegroundColor Cyan
    Write-Host "  Subscription: $script:SubscriptionName" -ForegroundColor Gray
    Write-Host "  Subscription ID: $script:SubscriptionId" -ForegroundColor Gray
    Write-Host "  Resource Group: $script:ResourceGroup" -ForegroundColor Gray
    Write-Host "  Location: $script:Location" -ForegroundColor Gray
    Write-Host "  Cluster Name: $script:ClusterName" -ForegroundColor Gray
    Write-Host "  Namespace: $script:NamespaceName" -ForegroundColor Gray
    Write-Host ""
    
    Write-Success "Azure authentication configured"
}

# ============================================================================
# KUBECONFIG SETUP
# ============================================================================

# Merge or set the user's kubeconfig so `kubectl` uses the desired context.
function Update-UserKubeConfig {
    param(
        [Parameter(Mandatory=$true)][string]$ContextName,
        [Parameter(Mandatory=$false)][string]$SourceKubeconfig
    )

    # Determine the user's primary kubeconfig file
    $userKube = $null
    if ($env:KUBECONFIG) {
        $userKube = $env:KUBECONFIG
    } else {
        $home = if ($env:USERPROFILE) { $env:USERPROFILE } else { $env:HOME }
        $userKube = Join-Path $home ".kube\config"
    }

    Write-InfoLog "Ensuring kubeconfig at: $userKube uses context: $ContextName"

    # If a source kubeconfig was provided, merge it with the user's kubeconfig
    if ($SourceKubeconfig -and (Test-Path $SourceKubeconfig)) {
        Write-InfoLog "Merging kubeconfigs: $SourceKubeconfig -> $userKube"

        # Set temporary KUBECONFIG to combine both files and flatten into a single file
        $originalKubeEnv = $env:KUBECONFIG
        $env:KUBECONFIG = "$userKube;$SourceKubeconfig"

        # Backup existing kubeconfig if present
        if (Test-Path $userKube) {
            $backupPath = "$userKube.bak.$(Get-Date -Format 'yyyyMMdd_HHmmss')"
            Write-InfoLog "Backing up existing kubeconfig to: $backupPath"

            if (-not $script:DryRun) {
                Copy-Item -Path $userKube -Destination $backupPath -Force
                Write-Success "Backup created: $backupPath"
            } else {
                Write-InfoLog "[DRY-RUN] Would copy $userKube to $backupPath"
            }

            # Prompt user for confirmation before overwriting
            if (-not $script:DryRun) {
                $confirm = Read-Host "This will overwrite your kubeconfig at $userKube (backup created at $backupPath). Continue? (y/N)"
                if ($confirm.ToLower() -ne 'y') {
                    Write-WarnLog "User declined to overwrite kubeconfig. Aborting kubeconfig merge."
                    # Restore original KUBECONFIG env if needed
                    if ($originalKubeEnv) { $env:KUBECONFIG = $originalKubeEnv } else { Remove-Item Env:KUBECONFIG -ErrorAction SilentlyContinue }
                    return
                }
            } else {
                Write-InfoLog "[DRY-RUN] Would prompt user to confirm overwrite of $userKube"
            }
        }

        try {
            & kubectl config view --flatten | Out-File -Encoding ascii -FilePath $userKube
            Write-Success "Merged kubeconfig written to: $userKube"
        } finally {
            if ($originalKubeEnv) { $env:KUBECONFIG = $originalKubeEnv } else { Remove-Item Env:KUBECONFIG -ErrorAction SilentlyContinue }
        }
    }

    # Ensure the desired context exists in the user's kubeconfig
    $contexts = & kubectl config get-contexts --kubeconfig $userKube 2>$null
    if ($LASTEXITCODE -ne 0) {
        throw "kubectl cannot read kubeconfig at $userKube"
    }

    if ($contexts -match [regex]::Escape($ContextName)) {
        Write-InfoLog "Setting current context to: $ContextName"
        & kubectl config use-context $ContextName --kubeconfig $userKube
        if ($LASTEXITCODE -ne 0) {
            throw "Failed to set context $ContextName in $userKube"
        }
        Write-Success "kubectl now using context: $ContextName"
    } else {
        throw "Context '$ContextName' not found in $userKube"
    }
}


# Check RBAC: detect 403s for listing nodes and generate minimal remediation
function Check-RBACAndSuggest {
    param(
        [Parameter(Mandatory=$true)][string]$KubeconfigPath
    )

    Write-Log "Checking RBAC permissions for current user/context..."

    # Test whether the current context can list nodes
    $canList = & kubectl --kubeconfig $KubeconfigPath auth can-i list nodes 2>&1
    $exit = $LASTEXITCODE

    if ($exit -eq 0 -and $canList -match 'yes') {
        Write-Success "Current user has permission to list nodes"
        return
    }

    Write-WarnLog "Current user lacks permission to list nodes (RBAC issue detected)"

    # Try to get Azure signed-in user (UPN) to use in suggested binding
    $azureUser = $null
    try {
        $azureUser = az account show --query user.name -o tsv 2>$null
    } catch {
        $azureUser = $null
    }

    if (-not $azureUser) {
        Write-InfoLog "Could not determine Azure signed-in user; admin should inspect kubeconfig user or object id"
    } else {
        Write-InfoLog "Detected Azure user: $azureUser"
    }

    # Generate a minimal ClusterRoleBinding YAML using 'view' role for the user
    $safeName = if ($azureUser) { $azureUser -replace '[^a-z0-9-]','-' } else { 'arc-user' }
    $yamlPath = Join-Path $script:ScriptDir "arc_node_read_binding_$((Get-Date).ToString('yyyyMMdd_HHmmss')).yaml"

    $subjectName = if ($azureUser) { $azureUser } else { '<AZURE_USER_UPN_OR_OBJECTID>' }

$yaml = @"
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: arc-nodes-reader-$safeName
subjects:
- kind: User
  name: $subjectName
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: view
  apiGroup: rbac.authorization.k8s.io
"@

    try {
        $yaml | Out-File -FilePath $yamlPath -Encoding utf8 -Force
        Write-Success "Generated ClusterRoleBinding YAML: $yamlPath"
    } catch {
        Write-WarnLog ("Failed to write YAML to {0}: {1}" -f $yamlPath, $_)
    }

    Write-Host ""
    Write-Host "RBAC remediation suggestions:" -ForegroundColor Cyan
    if ($azureUser) {
        Write-Host "  - (Recommended) On a cluster-admin session on the edge, run:" -ForegroundColor Gray
        Write-Host "      kubectl apply -f $yamlPath" -ForegroundColor Yellow
        Write-Host "    This grants the Azure user '$azureUser' read-only view permissions (including nodes)." -ForegroundColor Gray
    } else {
        Write-Host "  - On a cluster-admin session on the edge, either apply the generated YAML file or create a binding manually:" -ForegroundColor Gray
        Write-Host "      kubectl apply -f $yamlPath" -ForegroundColor Yellow
        Write-Host "    Replace the subject name in the YAML with the correct Azure UPN or object id if needed." -ForegroundColor Gray
    }

    Write-Host "  - For broader admin access (not recommended for production), an admin can run:" -ForegroundColor Gray
    Write-Host "      kubectl create clusterrolebinding arc-azure-admin-binding --clusterrole=cluster-admin --user=\"$subjectName\"" -ForegroundColor Yellow
    Write-Host "" -ForegroundColor Gray

    # Also print quick diagnostic output to help admins
    Write-Host "Diagnostics to collect for support:" -ForegroundColor Cyan
    Write-Host "  - kubectl --kubeconfig $KubeconfigPath auth can-i list nodes -v=8" -ForegroundColor Yellow
    Write-Host "  - kubectl --kubeconfig $KubeconfigPath config view --minify --raw" -ForegroundColor Yellow
    Write-Host "  - az account show" -ForegroundColor Yellow
    Write-Host ""
}



function Initialize-KubeConfig {
    Write-Log "Configuring kubectl for remote cluster access..."
    
    # If using Arc proxy, skip kubeconfig setup and start proxy instead
    if ($UseArcProxy) {
        Write-InfoLog "Using Azure Arc proxy for cluster connectivity"
        
        if (-not $script:ClusterName -or -not $script:ResourceGroup) {
            Write-ErrorLog "ClusterName and ResourceGroup must be configured to use Arc proxy" -Fatal
        }
        
        Write-Log "Starting Azure Arc proxy tunnel..."
        Write-InfoLog "Command: az connectedk8s proxy --name $script:ClusterName --resource-group $script:ResourceGroup"
        
        # Check if cluster is Arc-enabled
        $arcCluster = az connectedk8s show --name $script:ClusterName --resource-group $script:ResourceGroup 2>$null
        if (-not $arcCluster) {
            Write-ErrorLog "Cluster $script:ClusterName is not Arc-enabled in resource group $script:ResourceGroup"
            Write-Host ""
            Write-Host "To use Arc proxy, the cluster must first be Arc-enabled." -ForegroundColor Yellow
            Write-Host ""
            Write-Host "Arc-enable the cluster from the edge device:" -ForegroundColor Cyan
            Write-Host "  1. SSH to edge device: ssh billmanh@10.186.247.76" -ForegroundColor White
            Write-Host "  2. Install Azure CLI: curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash" -ForegroundColor White
            Write-Host "  3. Login: az login" -ForegroundColor White
            Write-Host "  4. Arc-enable: az connectedk8s connect --name $script:ClusterName --resource-group $script:ResourceGroup" -ForegroundColor White
            Write-Host ""
            Write-ErrorLog "Cluster must be Arc-enabled first" -Fatal
        }
        
        Write-Success "Cluster is Arc-enabled"
        
        # Clear any existing KUBECONFIG environment variable to ensure kubectl uses default location
        if ($env:KUBECONFIG) {
            Write-InfoLog "Clearing KUBECONFIG environment variable (was: $env:KUBECONFIG)"
            Remove-Item env:KUBECONFIG -ErrorAction SilentlyContinue
        }
        
        # The Arc proxy writes context to the default kubeconfig location
        $defaultKubeConfig = "$env:USERPROFILE\.kube\config"
        
        # Start the proxy in a background job - it will modify the default kubeconfig
        Write-InfoLog "Starting Arc proxy in background (this may take 15-30 seconds)...  "
        Write-InfoLog "The proxy will add a context to your default kubeconfig"
        $proxyJob = Start-Job -ScriptBlock {
            param($clusterName, $resourceGroup)
            az connectedk8s proxy --name $clusterName --resource-group $resourceGroup 2>&1
        } -ArgumentList $script:ClusterName, $script:ResourceGroup
        
        # Wait for proxy to be ready
        Write-InfoLog "Waiting for proxy tunnel to establish..."
        Start-Sleep -Seconds 25
        
        # Store proxy job for cleanup
        $script:ProxyJob = $proxyJob
        
        # Now backup the kubeconfig AFTER the proxy has modified it
        $backupKubeConfig = "$env:USERPROFILE\.kube\config.backup-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
        if (Test-Path $defaultKubeConfig) {
            Write-InfoLog "Backing up kubeconfig (after proxy modification) to: $backupKubeConfig"
            Copy-Item $defaultKubeConfig $backupKubeConfig -Force
        }
        
        # Verify the proxy is running and check for output
        Write-InfoLog "Checking proxy job status..."
        $jobState = $proxyJob.State
        Write-InfoLog "Proxy job state: $jobState"
        
        $proxyOutput = Receive-Job -Job $proxyJob -Keep 2>&1
        if ($proxyOutput) {
            Write-InfoLog "Proxy output: $proxyOutput"
        }
        
        # Check if kubeconfig was modified
        if (-not (Test-Path $defaultKubeConfig)) {
            Write-ErrorLog "Default kubeconfig does not exist at: $defaultKubeConfig"
            Write-InfoLog "The Arc proxy requires a kubeconfig file to exist"
            Write-InfoLog "Creating empty kubeconfig..."
            New-Item -Path "$env:USERPROFILE\.kube" -ItemType Directory -Force | Out-Null
            @"
apiVersion: v1
kind: Config
clusters: []
contexts: []
users: []
"@ | Out-File -FilePath $defaultKubeConfig -Encoding utf8
        }
        
        # Wait a bit more for proxy to write the context
        Write-InfoLog "Waiting for proxy to update kubeconfig..."
        Start-Sleep -Seconds 10
        
        # Check if the proxy added a context to the kubeconfig
        $proxyContextName = $script:ClusterName
        $contexts = kubectl config get-contexts -o name 2>&1
        Write-InfoLog "Available contexts: $($contexts -join ', ')"
        
        # Check if cluster exists even if context doesn't
        $clusters = kubectl config get-clusters 2>&1
        Write-InfoLog "Available clusters: $($clusters -join ', ')"
        
        if ($contexts -notcontains $proxyContextName) {
            Write-WarnLog "Proxy context '$proxyContextName' not found in kubeconfig"
            
            # Check if the cluster exists (proxy may have created cluster but not context)
            if ($clusters -contains $proxyContextName) {
                Write-InfoLog "Cluster '$proxyContextName' exists but context is missing"
                Write-InfoLog "Creating context for Arc proxy..."
                
                # The Arc proxy uses token-based auth - create a context that points to the cluster
                # The user will be "clusterUser_<resourcegroup>_<clustername>"
                $arcUser = "clusterUser_$($script:ResourceGroup)_$proxyContextName"
                
                Write-InfoLog "Creating context with cluster=$proxyContextName and user=$arcUser"
                kubectl config set-context $proxyContextName --cluster=$proxyContextName --user=$arcUser 2>&1 | Out-Null
                
                # Verify context was created
                $contextsAfter = kubectl config get-contexts -o name 2>&1
                if ($contextsAfter -contains $proxyContextName) {
                    Write-Success "Successfully created Arc proxy context"
                } else {
                    Write-ErrorLog "Failed to create Arc proxy context"
                    Write-InfoLog "Contexts after creation: $($contextsAfter -join ', ')"
                }
            } else {
                Write-WarnLog "Cluster '$proxyContextName' not found either"
                Write-InfoLog "Kubeconfig location: $defaultKubeConfig"
                Write-InfoLog "Checking kubeconfig content..."
                if (Test-Path $defaultKubeConfig) {
                    $kubeconfigPreview = Get-Content $defaultKubeConfig | Select-Object -First 30
                    Write-InfoLog "Kubeconfig preview: $kubeconfigPreview"
                }
                
                # Check if proxy is actually running
                if ($proxyJob.State -ne 'Running') {
                    Write-ErrorLog "Proxy job is not running. State: $($proxyJob.State)"
                    $jobErrors = Receive-Job -Job $proxyJob 2>&1
                    Write-ErrorLog "Proxy errors: $jobErrors"
                }
            }
        } else {
            Write-Success "Proxy context '$proxyContextName' found in kubeconfig"
        }
        
        # Set the proxy context as current
        Write-InfoLog "Setting current context to: $proxyContextName"
        kubectl config use-context $proxyContextName 2>&1 | Out-Null
        
        # Skip SSL verification for Arc proxy (self-signed certs)
        kubectl config set-cluster $proxyContextName --insecure-skip-tls-verify=true 2>&1 | Out-Null
        Write-InfoLog "SSL certificate verification disabled for Arc proxy (self-signed certs expected)"
        
        # Verify current context
        $currentContext = kubectl config current-context 2>&1
        Write-InfoLog "Current context after setting: $currentContext"
        
        # Verify the context points to the right place
        Write-InfoLog "Verifying context configuration..."
        $contextDetails = kubectl config view --minify 2>&1
        Write-InfoLog "Active context details: $($contextDetails | Out-String)"
        
        # Test connectivity using the proxy context
        Write-Log "Testing cluster connectivity through Arc proxy..."
        $nodes = kubectl --context=$proxyContextName get nodes --no-headers 2>&1
        if ($LASTEXITCODE -ne 0) {
            Write-WarnLog "Initial connectivity test failed, waiting a bit longer..."
            Start-Sleep -Seconds 10
            $nodes = kubectl --context=$proxyContextName get nodes --no-headers 2>&1
        }
        
        if ($LASTEXITCODE -ne 0) {
            Write-ErrorLog "Cannot connect through Arc proxy"
            Write-ErrorLog "Error: $nodes"
            Write-InfoLog "Checking proxy job status..."
            $jobOutput = Receive-Job -Job $proxyJob -Keep
            if ($jobOutput) {
                Write-InfoLog "Proxy output: $jobOutput"
            }
            Stop-Job -Job $proxyJob
            Remove-Job -Job $proxyJob
            Write-ErrorLog "Arc proxy connection failed" -Fatal
        }
        
        Write-Success "Successfully connected through Arc proxy"
        kubectl --context=$proxyContextName get nodes
        
        return
    }
    
    # Original kubeconfig setup for direct connectivity
    if (-not $script:ClusterData.kubeconfig_base64) {
        Write-ErrorLog "No kubeconfig data found in cluster_info.json" -Fatal
    }
    
    try {
        # Decode base64 kubeconfig
        $kubeconfigBytes = [System.Convert]::FromBase64String($script:ClusterData.kubeconfig_base64)
        $kubeconfigContent = [System.Text.Encoding]::UTF8.GetString($kubeconfigBytes)
        
        # Check if kubeconfig uses localhost and needs to be updated
        if ($kubeconfigContent -match 'server:\s*https?://127\.0\.0\.1:') {
            Write-WarnLog "Kubeconfig uses localhost (127.0.0.1) which won't work from a remote machine"
            
            # Try to get IP from cluster_info.json first
            $edgeDeviceAddress = $null
            if ($script:ClusterData.node_ip) {
                $edgeDeviceAddress = $script:ClusterData.node_ip
                Write-InfoLog "Using node IP from cluster_info.json: $edgeDeviceAddress"
            } else {
                # Prompt user for IP address
                Write-Host ""
                Write-Host "Please enter the IP address or hostname of your edge device ($($script:ClusterData.node_name)):" -ForegroundColor Yellow
                $edgeDeviceAddress = Read-Host "Edge device IP/hostname"
            }
            
            if (-not $edgeDeviceAddress) {
                Write-ErrorLog "Edge device address is required for remote cluster access" -Fatal
            }
            
            # Replace localhost with actual edge device address
            $kubeconfigContent = $kubeconfigContent -replace 'server:\s*https?://127\.0\.0\.1:', "server: https://${edgeDeviceAddress}:"
            Write-Success "Updated kubeconfig server address to: https://${edgeDeviceAddress}:6443"
        }
        
        # Save to temporary location
        $tempKubeConfig = Join-Path $env:TEMP "kubeconfig_$($script:ClusterName).yaml"
        Set-Content -Path $tempKubeConfig -Value $kubeconfigContent -NoNewline
        
        # Set KUBECONFIG environment variable for this session
        $env:KUBECONFIG = $tempKubeConfig
        
        Write-Success "Kubeconfig configured at: $tempKubeConfig"
        
        # Test connectivity
        Write-Log "Testing cluster connectivity..."
        $nodes = kubectl get nodes --no-headers 2>&1
        if ($LASTEXITCODE -ne 0) {
            Write-ErrorLog "Cannot connect to cluster. Please ensure network connectivity to edge device."
            Write-ErrorLog "Error: $nodes"
            Write-Host ""
            Write-Host "NETWORK CONNECTIVITY ISSUE DETECTED" -ForegroundColor Red
            Write-Host ""
            Write-Host "Arc-enabling a Kubernetes cluster requires kubectl access to deploy Arc agents." -ForegroundColor Yellow
            Write-Host "Since your Windows machine and edge device are on different networks," -ForegroundColor Yellow
            Write-Host "you have these options:" -ForegroundColor Yellow
            Write-Host ""
            Write-Host "OPTION 1 - Run from Edge Device (RECOMMENDED):" -ForegroundColor Cyan
            Write-Host "  SSH to your edge device and run Azure CLI commands directly there:" -ForegroundColor Gray
            Write-Host "  1. SSH to edge device: ssh user@$($script:ClusterData.node_ip)" -ForegroundColor White
            Write-Host "  2. Install Azure CLI: curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash" -ForegroundColor White
            Write-Host "  3. Login: az login" -ForegroundColor White
            Write-Host "  4. Set subscription: az account set --subscription $script:SubscriptionId" -ForegroundColor White
            Write-Host "  5. Arc-enable cluster:" -ForegroundColor White
            Write-Host "     az connectedk8s connect --name $script:ClusterName --resource-group $script:ResourceGroup" -ForegroundColor White
            Write-Host "  6. Deploy Azure IoT Operations:" -ForegroundColor White
            Write-Host "     az iot ops init --cluster $script:ClusterName --resource-group $script:ResourceGroup" -ForegroundColor White
            Write-Host ""
            Write-Host "OPTION 2 - VPN/Network Access:" -ForegroundColor Cyan
            Write-Host "  Set up VPN or network tunnel to access the edge device's network" -ForegroundColor Gray
            Write-Host ""
            Write-Host "OPTION 3 - Same Network:" -ForegroundColor Cyan
            Write-Host "  Run this script from a machine on the same network as the edge device" -ForegroundColor Gray
            Write-Host ""
            Write-Host "After Arc-enabling, you can use Azure Arc's cluster-connect feature:" -ForegroundColor Green
            Write-Host "  az connectedk8s proxy --name $script:ClusterName --resource-group $script:ResourceGroup" -ForegroundColor White
            Write-Host "  This creates a secure tunnel through Azure without exposing port 6443" -ForegroundColor Gray
            Write-Host ""
            Write-ErrorLog "Cannot establish connection to cluster" -Fatal
        }
        
        Write-Success "Successfully connected to cluster"
        kubectl get nodes

        # Merge the temporary kubeconfig into the user's kubeconfig and set the context
        try {
            Update-UserKubeConfig -ContextName $script:ClusterName -SourceKubeconfig $tempKubeConfig
        } catch {
            Write-WarnLog "Failed to update user kubeconfig from temp kubeconfig: $_"
        }
        
        # After updating kubeconfig, check RBAC and suggest remediation if needed
        try {
            $home = if ($env:USERPROFILE) { $env:USERPROFILE } else { $env:HOME }
            $userKube = Join-Path $home ".kube\config"
            Check-RBACAndSuggest -KubeconfigPath $userKube
        } catch {
            Write-WarnLog "RBAC check failed: $_"
        }
        
    } catch {
        Write-ErrorLog "Failed to configure kubeconfig: $_"
        
        # Check if kubectl is the issue
        if ($_.Exception.Message -like "*'kubectl' is not recognized*") {
            Write-Host ""
            Write-Host "kubectl is required but not found in PATH." -ForegroundColor Yellow
            Write-Host ""
            Write-Host "OPTION 1 - Using Azure CLI:" -ForegroundColor Cyan
            Write-Host "  Run: az aks install-cli" -ForegroundColor White
            Write-Host "  Then add to PATH:" -ForegroundColor Gray
            Write-Host "    `$env:Path += `";`$HOME\.azure-kubectl`"" -ForegroundColor White
            Write-Host "    [Environment]::SetEnvironmentVariable('Path', `$env:Path, 'User')" -ForegroundColor White
            Write-Host ""
            Write-Host "OPTION 2 - Using winget (handles PATH automatically):" -ForegroundColor Cyan
            Write-Host "  winget install -e --id Kubernetes.kubectl" -ForegroundColor White
            Write-Host ""
            Write-Host "OPTION 3 - Using Chocolatey (handles PATH automatically):" -ForegroundColor Cyan
            Write-Host "  choco install kubernetes-cli" -ForegroundColor White
            Write-Host ""
            Write-Host "After installation, close and reopen PowerShell, then run this script again." -ForegroundColor Yellow
            Write-Host ""
        }
        
        Write-ErrorLog "kubectl configuration failed" -Fatal
    }
}

# ============================================================================
# AZURE RESOURCE CREATION
# ============================================================================

function New-AzureResources {
    Write-Log "Creating Azure resources..."
    
    # Create resource group if it does not exist
    Write-Log "Checking resource group: $script:ResourceGroup"
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Would check/create resource group: $script:ResourceGroup"
        return
    }
    
    $rgExists = az group exists --name $script:ResourceGroup | ConvertFrom-Json
    
    if (-not $rgExists) {
        Write-Log "Creating resource group: $script:ResourceGroup in $script:Location"
        az group create --location $script:Location --resource-group $script:ResourceGroup --output none
        Write-Success "Resource group created: $script:ResourceGroup"
        $script:DeployedResources += "ResourceGroup:$script:ResourceGroup"
    } else {
        Write-Success "Resource group already exists: $script:ResourceGroup"
    }
}

# ============================================================================
# ARC ENABLEMENT
# ============================================================================

function Enable-ArcForCluster {
    if ($SkipArcEnable) {
        Write-InfoLog "Skipping Arc enablement (-SkipArcEnable flag)"
        return
    }
    
    Write-Log "Connecting cluster to Azure Arc..."
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Would Arc-enable cluster: $script:ClusterName"
        return
    }
    
    # Check if cluster is already Arc-enabled
    $arcCluster = az connectedk8s show --name $script:ClusterName --resource-group $script:ResourceGroup 2>$null
    
    if ($arcCluster) {
        Write-Success "Cluster $script:ClusterName is already Arc-enabled"
    } else {
        Write-Log "Connecting cluster to Azure Arc..."
        az connectedk8s connect --name $script:ClusterName --resource-group $script:ResourceGroup
        
        if ($LASTEXITCODE -ne 0) {
            Write-ErrorLog "Failed to Arc-enable cluster" -Fatal
        }
        
        Write-Success "Cluster Arc-enabled successfully"
        $script:DeployedResources += "ConnectedCluster:$script:ClusterName"
    }
    
    # Get OBJECT_ID for custom locations
    Write-Log "Getting Object ID for custom locations..."
    $objectId = az ad sp show --id bc313c14-388c-4e7d-a58e-70017303ee3b --query id -o tsv 2>$null
    
    if (-not $objectId) {
        Write-WarnLog "Could not retrieve custom locations service principal OID"
    } else {
        Write-InfoLog "Custom locations OID: $objectId"
        
        # Enable custom locations and cluster connect features
        Write-Log "Enabling custom locations and cluster connect features..."
        az connectedk8s enable-features `
            --name $script:ClusterName `
            --resource-group $script:ResourceGroup `
            --custom-locations-oid $objectId `
            --features cluster-connect custom-locations
        
        Write-Success "Custom locations and cluster connect enabled"
    }
    
    # Note: K3s restart is handled on the edge device, not from here
    Write-InfoLog "Note: If cluster connectivity issues occur, restart K3s on the edge device: sudo systemctl restart k3s"
}

# ============================================================================
# AZURE IOT OPERATIONS DEPLOYMENT
# ============================================================================

function New-IoTOperationsInstance {
    Write-Log "Deploying Azure IoT Operations..."
    
    # Enable UTF-8 encoding for Azure CLI IoT Operations commands
    # This must be done here (not at script start) to avoid corrupting JSON parsing from earlier az commands
    [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
    $env:PYTHONIOENCODING = "utf-8"
    $env:PYTHONUTF8 = "1"
    chcp 65001 2>&1 | Out-Null
    Write-InfoLog "UTF-8 encoding enabled for IoT Operations deployment"
    
    $instanceName = "$script:ClusterName-aio"
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Would deploy Azure IoT Operations instance: $instanceName"
        return
    }
    
    # Check if instance already exists
    $existingInstance = az iot ops show --name $instanceName --resource-group $script:ResourceGroup 2>&1
    
    if ($LASTEXITCODE -eq 0) {
        Write-Success "Azure IoT Operations instance $instanceName already exists"
        Write-InfoLog "To redeploy, delete the existing instance first:"
        Write-InfoLog "az iot ops delete --name $instanceName --resource-group $script:ResourceGroup"
        return
    }
    
    Write-InfoLog "Azure IoT Operations instance not found. Proceeding with deployment..."
    
    # Initialize cluster for Azure IoT Operations
    Write-Log "Initializing cluster for Azure IoT Operations..."
    az iot ops init --cluster $script:ClusterName --resource-group $script:ResourceGroup
    
    # Ensure Microsoft.Storage provider is registered
    Write-Log "Checking Azure resource provider registrations..."
    $storageProvider = az provider show --namespace Microsoft.Storage --query "registrationState" -o tsv 2>$null
    
    if ($storageProvider -ne "Registered") {
        Write-Log "Registering Microsoft.Storage resource provider..."
        az provider register --namespace Microsoft.Storage
        
        # Wait for registration
        Write-Log "Waiting for Microsoft.Storage provider registration..."
        do {
            Start-Sleep -Seconds 10
            $storageProvider = az provider show --namespace Microsoft.Storage --query registrationState -o tsv
            Write-InfoLog "Registration state: $storageProvider"
        } while ($storageProvider -ne "Registered")
        
        Write-Success "Microsoft.Storage provider registered"
    }
    
    # Create schema registry
    $schemaRegistryName = "$script:ClusterName-schema-registry"
    $storageAccountName = ($script:ClusterName + "storage").ToLower() -replace '[^a-z0-9]', '' | Select-Object -First 24
    
    New-SchemaRegistry -SchemaRegistryName $schemaRegistryName -StorageAccountName $storageAccountName
    
    # Get schema registry resource ID
    $schemaRegistryId = az iot ops schema registry show `
        --name $schemaRegistryName `
        --resource-group $script:ResourceGroup `
        --query id -o tsv
    
    # Create or verify Device Registry namespace
    New-DeviceRegistryNamespace
    
    # Construct namespace resource ID
    $namespaceResourceId = "/subscriptions/$script:SubscriptionId/resourceGroups/$script:ResourceGroup/providers/Microsoft.DeviceRegistry/namespaces/$script:NamespaceName"
    
    Write-Log "Using namespace resource ID: $namespaceResourceId"
    Write-Log "Using schema registry ID: $schemaRegistryId"
    
    # Deploy Azure IoT Operations
    Write-Log "Deploying Azure IoT Operations instance - this may take several minutes..."
    Write-InfoLog "Note: Progress display suppressed to avoid unicode rendering issues"
    
    $deployResult = az iot ops create `
        --cluster $script:ClusterName `
        --resource-group $script:ResourceGroup `
        --name $instanceName `
        --sr-resource-id $schemaRegistryId `
        --ns-resource-id $namespaceResourceId `
        --no-progress 2>&1
    
    if ($LASTEXITCODE -ne 0) {
        Write-ErrorLog "Azure IoT Operations deployment failed"
        Write-ErrorLog "Error: $deployResult"
        Write-ErrorLog "Check Azure portal for more details" -Fatal
    }
    
    Write-Success "Azure IoT Operations deployed successfully!"
    $script:DeployedResources += "IoTOperationsInstance:$instanceName"
    
    # Enable resource sync
    if ($script:EnableResourceSync) {
        Enable-ResourceSync -InstanceName $instanceName
    }
}

function New-SchemaRegistry {
    param(
        [string]$SchemaRegistryName,
        [string]$StorageAccountName
    )
    
    Write-Log "Setting up schema registry..."
    
    # Check if schema registry exists
    $existingRegistry = az iot ops schema registry show `
        --name $SchemaRegistryName `
        --resource-group $script:ResourceGroup 2>$null
    
    if ($existingRegistry) {
        Write-Success "Schema registry $SchemaRegistryName already exists"
        return
    }
    
    # Create storage account
    Write-Log "Creating storage account: $StorageAccountName"
    
    $existingStorage = az storage account show `
        --name $StorageAccountName `
        --resource-group $script:ResourceGroup 2>$null
    
    if (-not $existingStorage) {
        az storage account create `
            --name $StorageAccountName `
            --resource-group $script:ResourceGroup `
            --location $script:Location `
            --sku Standard_LRS `
            --kind StorageV2 `
            --enable-hierarchical-namespace true `
            --allow-blob-public-access false `
            --output none
        
        Write-Success "Storage account created: $StorageAccountName"
    } else {
        Write-Success "Storage account already exists: $StorageAccountName"
    }
    
    # Create container
    $containerName = "schemas"
    Write-Log "Creating storage container: $containerName"
    
    $containerExists = az storage container exists `
        --name $containerName `
        --account-name $StorageAccountName `
        --auth-mode login `
        --query exists -o tsv 2>$null
    
    if ($containerExists -ne "true") {
        az storage container create `
            --name $containerName `
            --account-name $StorageAccountName `
            --auth-mode login `
            --output none
        
        Write-Success "Storage container created: $containerName"
    } else {
        Write-Success "Storage container already exists: $containerName"
    }
    
    # Get storage account resource ID
    $storageAccountId = az storage account show `
        --name $StorageAccountName `
        --resource-group $script:ResourceGroup `
        --query id -o tsv
    
    # Create schema registry
    Write-Log "Creating schema registry: $SchemaRegistryName"
    
    az iot ops schema registry create `
        --name $SchemaRegistryName `
        --resource-group $script:ResourceGroup `
        --registry-namespace $script:NamespaceName `
        --sa-resource-id $storageAccountId `
        --output none
    
    Write-Success "Schema registry created: $SchemaRegistryName"
    $script:DeployedResources += "SchemaRegistry:$SchemaRegistryName"
}

function New-DeviceRegistryNamespace {
    Write-Log "Configuring Device Registry namespace..."
    
    # Check if namespace already exists
    $existingNamespace = az resource show `
        --ids "/subscriptions/$script:SubscriptionId/resourceGroups/$script:ResourceGroup/providers/Microsoft.DeviceRegistry/namespaces/$script:NamespaceName" 2>&1
    
    if ($LASTEXITCODE -eq 0) {
        Write-Success "Device Registry namespace already exists: $script:NamespaceName"
        return
    }
    
    Write-Log "Creating Device Registry namespace: $script:NamespaceName"
    
    # Create the namespace using az resource create
    $namespaceResult = az resource create `
        --resource-group $script:ResourceGroup `
        --namespace Microsoft.DeviceRegistry `
        --resource-type namespaces `
        --name $script:NamespaceName `
        --properties '{}' `
        --api-version 2025-10-01 2>&1
    
    if ($LASTEXITCODE -ne 0) {
        Write-ErrorLog "Failed to create Device Registry namespace: $namespaceResult"
        Write-ErrorLog "This is required for Azure IoT Operations deployment" -Fatal
    }
    
    Write-Success "Device Registry namespace created: $script:NamespaceName"
    $script:DeployedResources += "DeviceRegistryNamespace:$script:NamespaceName"
}

function Enable-ResourceSync {
    param([string]$InstanceName)
    
    Write-Log "Enabling edge-to-cloud asset sync..."
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Would enable resource sync for: $InstanceName"
        return
    }
    
    $rsyncResult = az iot ops enable-rsync `
        --name $InstanceName `
        --resource-group $script:ResourceGroup 2>&1
    
    if ($LASTEXITCODE -ne 0) {
        Write-WarnLog "Failed to enable asset sync automatically"
        Write-InfoLog "You can enable it manually later with:"
        Write-InfoLog "az iot ops enable-rsync --name $InstanceName --resource-group $script:ResourceGroup"
        
        # Try with explicit K8 Bridge service principal OID
        Write-Log "Attempting with explicit K8 Bridge service principal OID..."
        $k8BridgeOid = az ad sp list --display-name "K8 Bridge" --query "[0].id" -o tsv 2>$null
        
        if ($k8BridgeOid) {
            Write-InfoLog "Found K8 Bridge service principal OID: $k8BridgeOid"
            
            $rsyncResult = az iot ops enable-rsync `
                --name $InstanceName `
                --resource-group $script:ResourceGroup `
                --k8-bridge-sp-oid $k8BridgeOid 2>&1
            
            if ($LASTEXITCODE -eq 0) {
                Write-Success "Asset sync enabled successfully with explicit OID"
            } else {
                Write-WarnLog "Failed to enable asset sync even with explicit OID"
                Write-WarnLog "Manual intervention may be required"
            }
        } else {
            Write-WarnLog "Could not retrieve K8 Bridge service principal OID"
        }
    } else {
        Write-Success "Asset sync enabled successfully!"
        Write-InfoLog "Discovered assets on the edge will now be surfaced in the cloud"
    }
}

# ============================================================================
# KEY VAULT INTEGRATION
# ============================================================================

function New-KeyVaultForAIO {
    if ($SkipKeyVault) {
        Write-InfoLog "Skipping Key Vault setup (-SkipKeyVault flag)"
        return
    }
    
    Write-Log "Setting up Azure Key Vault for secret management..."
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Would create Key Vault and configure integration"
        return
    }
    
    # Generate Key Vault name if not provided
    if (-not $script:KeyVaultName) {
        # Key Vault names must be globally unique, 3-24 chars, alphanumeric and hyphens
        # Must begin with letter, end with letter/digit, no consecutive hyphens
        $uniqueSuffix = -join ((48..57) + (97..122) | Get-Random -Count 6 | ForEach-Object {[char]$_})
        
        # Remove non-alphanumeric from cluster name to avoid consecutive hyphens
        $cleanClusterName = $script:ClusterName -replace '[^a-zA-Z0-9]', ''
        
        # Build name and ensure it starts with letter
        $script:KeyVaultName = "aio$cleanClusterName$uniqueSuffix"
        
        # Truncate to 24 chars max
        if ($script:KeyVaultName.Length -gt 24) {
            $script:KeyVaultName = $script:KeyVaultName.Substring(0, 24)
        }
        
        # Ensure it ends with alphanumeric (trim trailing hyphens if any)
        $script:KeyVaultName = $script:KeyVaultName.TrimEnd('-')
        
        Write-InfoLog "Generated Key Vault name: $script:KeyVaultName"
    }
    
    # Check if Key Vault already exists
    $existingKv = az keyvault show --name $script:KeyVaultName --resource-group $script:ResourceGroup 2>$null
    
    if ($existingKv) {
        Write-Success "Key Vault $script:KeyVaultName already exists"
        $kvData = $existingKv | ConvertFrom-Json
        Write-InfoLog "Vault URI: $($kvData.properties.vaultUri)"
    } else {
        Write-Log "Creating Key Vault: $script:KeyVaultName"
        
        $kvResult = az keyvault create `
            --name $script:KeyVaultName `
            --resource-group $script:ResourceGroup `
            --location $script:Location `
            --enable-rbac-authorization true `
            --enabled-for-deployment true `
            --enabled-for-template-deployment true `
            --output json 2>&1
        
        if ($LASTEXITCODE -ne 0) {
            Write-ErrorLog "Failed to create Key Vault: $kvResult"
            Write-WarnLog "Continuing without Key Vault integration"
            return
        }
        
        $kvData = $kvResult | ConvertFrom-Json
        Write-Success "Key Vault created: $script:KeyVaultName"
        Write-InfoLog "Vault URI: $($kvData.properties.vaultUri)"
        $script:DeployedResources += "KeyVault:$script:KeyVaultName"
    }
    
    # Grant Key Vault permissions to Arc cluster and AIO managed identities
    Grant-KeyVaultPermissions
    
    # Create SecretProviderClass on Kubernetes cluster
    New-SecretProviderClass
    
    Write-Success "Key Vault integration configured successfully"
}

function Grant-KeyVaultPermissions {
    Write-Log "Granting Key Vault permissions to managed identities..."
    
    # Get current user's object ID for initial setup
    $currentUserOid = az ad signed-in-user show --query id -o tsv 2>$null
    if ($currentUserOid) {
        Write-Log "Granting 'Key Vault Administrator' role to current user for initial setup..."
        az role assignment create `
            --role "Key Vault Administrator" `
            --assignee $currentUserOid `
            --scope "/subscriptions/$script:SubscriptionId/resourceGroups/$script:ResourceGroup/providers/Microsoft.KeyVault/vaults/$script:KeyVaultName" `
            --output none 2>$null
        Write-Success "Current user granted Key Vault Administrator access"
    }
    
    # Get Arc cluster managed identity
    $arcCluster = az connectedk8s show --name $script:ClusterName --resource-group $script:ResourceGroup 2>$null | ConvertFrom-Json
    
    if ($arcCluster.identity -and $arcCluster.identity.principalId) {
        Write-Log "Granting 'Key Vault Secrets User' role to Arc cluster identity..."
        
        az role assignment create `
            --role "Key Vault Secrets User" `
            --assignee $arcCluster.identity.principalId `
            --scope "/subscriptions/$script:SubscriptionId/resourceGroups/$script:ResourceGroup/providers/Microsoft.KeyVault/vaults/$script:KeyVaultName" `
            --output none 2>$null
        
        Write-Success "Arc cluster identity granted Key Vault Secrets User access"
        Write-InfoLog "Principal ID: $($arcCluster.identity.principalId)"
    } else {
        Write-WarnLog "Arc cluster has no managed identity - Key Vault access not configured"
    }
    
    # Get AIO instance managed identity
    $instanceName = "$script:ClusterName-aio"
    $aioInstance = az iot ops show --name $instanceName --resource-group $script:ResourceGroup 2>$null | ConvertFrom-Json
    
    if ($aioInstance.identity -and $aioInstance.identity.principalId) {
        Write-Log "Granting 'Key Vault Secrets User' role to AIO instance identity..."
        
        az role assignment create `
            --role "Key Vault Secrets User" `
            --assignee $aioInstance.identity.principalId `
            --scope "/subscriptions/$script:SubscriptionId/resourceGroups/$script:ResourceGroup/providers/Microsoft.KeyVault/vaults/$script:KeyVaultName" `
            --output none 2>$null
        
        Write-Success "AIO instance identity granted Key Vault Secrets User access"
        Write-InfoLog "Principal ID: $($aioInstance.identity.principalId)"
    } else {
        Write-WarnLog "AIO instance has no managed identity - Key Vault access not configured"
    }
    
    # Grant access to all managed identities in the resource group (belt and suspenders)
    Write-Log "Checking for additional managed identities in resource group..."
    $identities = az identity list --resource-group $script:ResourceGroup 2>$null | ConvertFrom-Json
    
    if ($identities -and $identities.Count -gt 0) {
        foreach ($identity in $identities) {
            Write-Log "Granting access to managed identity: $($identity.name)"
            
            az role assignment create `
                --role "Key Vault Secrets User" `
                --assignee $identity.principalId `
                --scope "/subscriptions/$script:SubscriptionId/resourceGroups/$script:ResourceGroup/providers/Microsoft.KeyVault/vaults/$script:KeyVaultName" `
                --output none 2>$null
            
            Write-InfoLog "  Granted access to: $($identity.name) ($($identity.principalId))"
        }
    }
}

function New-SecretProviderClass {
    Write-Log "Creating SecretProviderClass on Kubernetes cluster..."
    
    # Get Key Vault details
    $kvData = az keyvault show --name $script:KeyVaultName --resource-group $script:ResourceGroup | ConvertFrom-Json
    $kvUri = $kvData.properties.vaultUri.TrimEnd('/')
    
    # Get tenant ID
    $tenantId = az account show --query tenantId -o tsv
    
    # Create SecretProviderClass YAML
    $spcYaml = @"
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: aio-akv-sp
  namespace: azure-iot-operations
spec:
  provider: azure
  parameters:
    usePodIdentity: "false"
    useVMManagedIdentity: "true"
    clientID: ""
    keyvaultName: $script:KeyVaultName
    cloudName: AzurePublicCloud
    objects: |
      array:
        - |
          objectName: fabric-connection-string
          objectType: secret
          objectVersion: ""
    tenantId: $tenantId
"@
    
    # Save to temporary file
    $spcFile = Join-Path $env:TEMP "secretproviderclass-aio.yaml"
    $spcYaml | Out-File -FilePath $spcFile -Encoding utf8 -Force
    
    # Apply to cluster
    try {
        kubectl apply -f $spcFile 2>&1 | Out-Null
        
        if ($LASTEXITCODE -eq 0) {
            Write-Success "SecretProviderClass 'aio-akv-sp' created in azure-iot-operations namespace"
            Write-InfoLog "AIO dataflows can now reference secrets as: aio-akv-sp/<secret-name>"
        } else {
            Write-WarnLog "Failed to create SecretProviderClass - check kubectl connectivity"
        }
    } catch {
        Write-WarnLog "Could not create SecretProviderClass: $_"
    } finally {
        # Clean up temp file
        if (Test-Path $spcFile) {
            Remove-Item $spcFile -Force
        }
    }
}

function Add-SampleSecretsToKeyVault {
    param([switch]$Interactive)
    
    if (-not $Interactive) {
        return
    }
    
    Write-Host ""
    Write-Host "Would you like to add sample secrets to the Key Vault? (y/N)" -ForegroundColor Yellow
    $addSecrets = Read-Host
    
    if ($addSecrets -ne 'y' -and $addSecrets -ne 'Y') {
        return
    }
    
    Write-Log "Adding sample secrets to Key Vault..."
    
    # Example: Fabric connection string placeholder
    $fabricConnStr = Read-Host "Enter Fabric Real-Time Intelligence connection string (or press Enter to skip)"
    
    if (-not [string]::IsNullOrWhiteSpace($fabricConnStr)) {
        az keyvault secret set `
            --vault-name $script:KeyVaultName `
            --name "fabric-connection-string" `
            --value $fabricConnStr `
            --output none 2>$null
        
        if ($LASTEXITCODE -eq 0) {
            Write-Success "Stored secret: fabric-connection-string"
            Write-InfoLog "Reference in dataflows as: aio-akv-sp/fabric-connection-string"
        } else {
            Write-WarnLog "Failed to store secret"
        }
    }
    
    Write-InfoLog "You can add more secrets with: az keyvault secret set --vault-name $script:KeyVaultName --name <secret-name> --value <secret-value>"
}

# ============================================================================
# VERIFICATION
# ============================================================================

function Test-Deployment {
    if ($SkipVerification) {
        Write-InfoLog "Skipping deployment verification (-SkipVerification flag)"
        return
    }
    
    Write-Log "Verifying deployment..."
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Would verify deployment"
        return
    }
    
    # Verify resource group
    $rgExists = az group exists --name $script:ResourceGroup | ConvertFrom-Json
    if (-not $rgExists) {
        Write-ErrorLog "Resource group not found: $script:ResourceGroup"
        return
    }
    Write-Success "Resource group verified: $script:ResourceGroup"
    
    # Verify Arc connection
    if (-not $SkipArcEnable) {
        $arcCluster = az connectedk8s show --name $script:ClusterName --resource-group $script:ResourceGroup 2>&1
        if ($LASTEXITCODE -eq 0) {
            $arcData = $arcCluster | ConvertFrom-Json
            Write-Success "Arc-enabled cluster verified: $script:ClusterName (State: $($arcData.connectivityStatus))"
        } else {
            Write-WarnLog "Arc-enabled cluster not found: $script:ClusterName"
        }
    }
    
    # Verify IoT Operations instance
    $instanceName = "$script:ClusterName-aio"
    $iotOps = az iot ops show --name $instanceName --resource-group $script:ResourceGroup 2>&1
    
    if ($LASTEXITCODE -eq 0) {
        $iotOpsData = $iotOps | ConvertFrom-Json
        Write-Success "Azure IoT Operations instance verified: $instanceName (State: $($iotOpsData.provisioningState))"
    } else {
        Write-WarnLog "Azure IoT Operations instance not found: $instanceName"
    }
    
    # Verify CSI Secret Store
    Write-Log "Checking CSI Secret Store for secret management..."
    $csiInstalled = Test-CSISecretStore
    
    if ($csiInstalled) {
        Write-Host ""
        Write-Host "[OK] Secret management is ENABLED" -ForegroundColor Green
        Write-Host "   You can now configure Fabric RTI dataflows with Azure Key Vault secrets" -ForegroundColor Green
        Write-Host ""
    } else {
        Write-Host ""
        Write-Host "[WARNING] Secret management is DISABLED" -ForegroundColor Yellow
        Write-Host "   Fabric RTI dataflows will NOT work until CSI Secret Store is installed" -ForegroundColor Yellow
        Write-Host ""
    }
    
    # Verify Key Vault (if created)
    if (-not $SkipKeyVault -and $script:KeyVaultName) {
        Write-Log "Verifying Key Vault integration..."
        $kvExists = az keyvault show --name $script:KeyVaultName --resource-group $script:ResourceGroup 2>$null
        
        if ($kvExists) {
            $kvData = $kvExists | ConvertFrom-Json
            Write-Success "Key Vault verified: $script:KeyVaultName"
            Write-InfoLog "Vault URI: $($kvData.properties.vaultUri)"
            
            # Check for SecretProviderClass
            try {
                $spc = kubectl get secretproviderclass aio-akv-sp -n azure-iot-operations --ignore-not-found 2>&1
                if ($spc) {
                    Write-Success "SecretProviderClass 'aio-akv-sp' is configured"
                    Write-InfoLog "Dataflows can reference secrets as: aio-akv-sp/<secret-name>"
                } else {
                    Write-WarnLog "SecretProviderClass 'aio-akv-sp' not found"
                }
            } catch {
                Write-WarnLog "Could not verify SecretProviderClass"
            }
        } else {
            Write-WarnLog "Key Vault not found: $script:KeyVaultName"
        }
    }
    
    # Check cluster pods
    Write-Log "Checking cluster resources..."
    kubectl get pods --all-namespaces
    
    Write-Success "Deployment verification completed"
}

# ============================================================================
# DEPLOYMENT SUMMARY
# ============================================================================

function Export-DeploymentSummary {
    Write-Log "Generating deployment summary..."
    
    $summary = @{
        timestamp = Get-Date -Format "o"
        cluster_name = $script:ClusterName
        azure = @{
            subscription_id = $script:SubscriptionId
            subscription_name = $script:SubscriptionName
            resource_group = $script:ResourceGroup
            location = $script:Location
            namespace_name = $script:NamespaceName
            key_vault_name = $script:KeyVaultName
        }
        deployment = @{
            deployment_mode = $script:DeploymentMode
            deployed_resources = $script:DeployedResources
            errors = $script:Errors
        }
        configurator_version = "1.0.0"
        dry_run = $DryRun.IsPresent
    }
    
    # Add cluster info if available
    if ($script:ClusterData) {
        $summary.cluster = @{
            node_name = $script:ClusterData.node_name
            kubernetes_version = $script:ClusterData.kubernetes_version
            node_os = $script:ClusterData.node_os
            deployed_modules = $script:ClusterData.deployed_modules
            installed_tools = $script:ClusterData.installed_tools
        }
    }
    
    $summary | ConvertTo-Json -Depth 10 | Set-Content -Path $script:DeploymentSummaryFile
    
    Write-Success "Deployment summary saved to: $script:DeploymentSummaryFile"
}

# ============================================================================
# FINAL SUMMARY DISPLAY
# ============================================================================

function Show-CompletionSummary {
    Write-Host ""
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host "Azure IoT Operations Configuration Completed!" -ForegroundColor Cyan
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host ""
    
    Write-Host "Deployed Resources:" -ForegroundColor Green
    foreach ($resource in $script:DeployedResources) {
        Write-Host "  + $resource" -ForegroundColor Gray
    }
    Write-Host ""
    
    if ($script:Errors.Count -gt 0) {
        Write-Host "Errors Encountered:" -ForegroundColor Red
        foreach ($errors in $script:Errors) {
            Write-Host "  - $errors" -ForegroundColor Gray
        }
        Write-Host ""
    }
    
    Write-Host "Azure Resources:" -ForegroundColor Cyan
    Write-Host "  Subscription: $script:SubscriptionName ($script:SubscriptionId)" -ForegroundColor Gray
    Write-Host "  Resource Group: $script:ResourceGroup" -ForegroundColor Gray
    Write-Host "  Location: $script:Location" -ForegroundColor Gray
    Write-Host "  IoT Operations Instance: $($script:ClusterName)-aio" -ForegroundColor Gray
    if ($script:KeyVaultName) {
        Write-Host "  Key Vault: $script:KeyVaultName" -ForegroundColor Gray
    }
    Write-Host ""
    Write-Host "View in Azure Portal: https://portal.azure.com" -ForegroundColor Cyan
    Write-Host ""
    
    Write-Host "Next Steps:" -ForegroundColor Green
    Write-Host "  1. View deployment summary: cat `$script:DeploymentSummaryFile" -ForegroundColor Gray
    Write-Host "  2. Monitor cluster: kubectl get pods -A" -ForegroundColor Gray
    Write-Host "  3. Check Azure portal for resource status" -ForegroundColor Gray
    if ($script:KeyVaultName) {
        Write-Host "  4. Add secrets to Key Vault: az keyvault secret set --vault-name $script:KeyVaultName --name <name> --value <value>" -ForegroundColor Gray
        Write-Host "  5. Reference secrets in dataflows as: aio-akv-sp/<secret-name>" -ForegroundColor Gray
        Write-Host "  6. Deploy MQTT assets and configure Fabric RTI dataflows" -ForegroundColor Gray
    } else {
        Write-Host "  4. Deploy MQTT assets (if applicable)" -ForegroundColor Gray
    }
    Write-Host ""
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host ""
    
    if ($DryRun) {
        Write-Host "NOTE: This was a DRY-RUN. No actual changes were made." -ForegroundColor Yellow
        Write-Host ""
    }
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

function Main {
    try {
        # Initialize logging
        Initialize-Logging
        
        Write-Log "Starting Azure IoT Operations External Configurator"
        Write-Log "Version: 1.0.0 (Separation of Concerns)"

        # If the user did not explicitly request direct kubeconfig access,
        # assume the script is running from a different network than the
        # edge device and prefer using the Azure Arc proxy via the Azure CLI.
        if (-not $PSBoundParameters.ContainsKey('UseArcProxy') -and -not $UseArcProxy) {
            $UseArcProxy = $true
            Write-Host "Assuming this machine is on a different network than the edge device; enabling Azure Arc proxy mode by default." -ForegroundColor Yellow
            Write-Host "If you want to force direct kubeconfig usage, run the script with -UseArcProxy:$false or provide the -SkipArcEnable flag." -ForegroundColor Yellow
        }
        Write-Host ""
        
        # Phase 1: Prerequisites and Configuration
        Test-Prerequisites
        Import-ClusterInfo
        Import-AzureConfig
        
        # Phase 2: Azure Authentication
        Connect-ToAzure
        
        # Phase 3: Cluster Connectivity
        Initialize-KubeConfig
        
        # Phase 4: Azure Resource Creation
        New-AzureResources
        
        # Phase 5: Arc Enablement
        Enable-ArcForCluster
        
        # Phase 5.5: Verify CSI Secret Store (for Fabric RTI support)
        Write-Host ""
        Write-Host "============================================================================" -ForegroundColor Cyan
        Write-Host "Checking for Secret Management Prerequisites" -ForegroundColor Cyan
        Write-Host "============================================================================" -ForegroundColor Cyan
        Test-CSISecretStore
        Write-Host ""
        
        # Phase 6: IoT Operations Deployment
        New-IoTOperationsInstance
        
        # Phase 6.5: Key Vault Integration (after AIO deployment)
        if (-not $SkipKeyVault) {
            Write-Host ""
            Write-Host "============================================================================" -ForegroundColor Cyan
            Write-Host "Setting Up Key Vault Integration" -ForegroundColor Cyan
            Write-Host "============================================================================" -ForegroundColor Cyan
            New-KeyVaultForAIO
            
            # Optionally add sample secrets
            Add-SampleSecretsToKeyVault -Interactive
            Write-Host ""
        }
        
        # Phase 7: Verification
        Test-Deployment
        
        # Phase 8: Summary
        Export-DeploymentSummary
        Show-CompletionSummary
        
        Write-Success "External configuration completed successfully!"
        
    } catch {
        Write-ErrorLog "Unexpected error: $_"
        Write-ErrorLog $_.ScriptStackTrace
        
        if ($script:Errors.Count -gt 0) {
            Write-Host ""
            Write-Host "Errors encountered during execution:" -ForegroundColor Red
            foreach ($err in $script:Errors) {
                Write-Host "  - $err" -ForegroundColor Gray
            }
        }
        
        throw
    } finally {
        # Cleanup Arc proxy job if it was started
        if ($script:ProxyJob) {
            Write-InfoLog "Stopping Arc proxy job..."
            Stop-Job -Job $script:ProxyJob -ErrorAction SilentlyContinue
            Remove-Job -Job $script:ProxyJob -ErrorAction SilentlyContinue
        }
        # Stop transcription if running; ignore error if not transcribing
        try {
            Stop-Transcript
        } catch {
            # Ignore Stop-Transcript errors when transcription isn't active
        }
    }
}

# Run main function
Main
