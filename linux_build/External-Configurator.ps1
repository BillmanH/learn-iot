<#
.SYNOPSIS
    Azure IoT Operations - External Configurator (PowerShell)

.DESCRIPTION
    This script connects edge K3s clusters to Azure Arc and deploys Azure IoT Operations.
    It runs on a Windows management machine with Azure CLI and handles all Azure resource creation.
    
    Requirements:
    - Windows 10/11 or Windows Server 2019+
    - PowerShell 5.1+ or PowerShell 7+
    - Azure CLI installed
    - Azure credentials with appropriate permissions
    - cluster_info.json from linux_installer.sh
    - Network connectivity to edge device (for kubectl commands)
    
.PARAMETER ClusterInfo
    Path to cluster_info.json file generated by linux_installer.sh
    
.PARAMETER ConfigFile
    Path to azure_config.json configuration file (default: azure_config.json)
    
.PARAMETER DryRun
    Validate configuration without making changes
    
.PARAMETER SkipArcEnable
    Skip Arc-enabling the cluster (useful if already Arc-enabled)
    
.PARAMETER SkipVerification
    Skip post-deployment verification
    
.EXAMPLE
    .\External-Configurator.ps1 -ClusterInfo cluster_info.json
    
.EXAMPLE
    .\External-Configurator.ps1 -ClusterInfo cluster_info.json -ConfigFile linux_aio_config.json -DryRun
    
.NOTES
    Author: Azure IoT Operations Team
    Date: January 2026
    Version: 1.0.0 - External Configurator (Separation of Concerns)
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [string]$ClusterInfo = "cluster_info.json",
    
    [Parameter(Mandatory=$false)]
    [string]$ConfigFile = "",
    
    [Parameter(Mandatory=$false)]
    [switch]$DryRun,
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipArcEnable,
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipVerification
)

# ============================================================================
# GLOBAL VARIABLES
# ============================================================================

$script:ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$script:LogFile = Join-Path $script:ScriptDir "external_configurator_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
$script:DeploymentSummaryFile = Join-Path $script:ScriptDir "deployment_summary.json"

# Configuration variables (loaded from files)
$script:ClusterData = $null
$script:AzureConfig = $null
$script:SubscriptionId = $null
$script:SubscriptionName = $null
$script:ResourceGroup = $null
$script:Location = $null
$script:ClusterName = $null
$script:NamespaceName = $null
$script:DeployMqttAssets = $true
$script:EnableResourceSync = $true
$script:DeploymentMode = "production"

# Deployment tracking
$script:DeployedResources = @()
$script:Errors = @()

# ============================================================================
# LOGGING FUNCTIONS
# ============================================================================

function Initialize-Logging {
    Start-Transcript -Path $script:LogFile -Append
    
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host "Azure IoT Operations - External Configurator" -ForegroundColor Cyan
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host "Log file: $script:LogFile" -ForegroundColor Gray
    Write-Host "Started: $(Get-Date)" -ForegroundColor Gray
    Write-Host "Script directory: $script:ScriptDir" -ForegroundColor Gray
    Write-Host ""
    
    if ($DryRun) {
        Write-Warning "RUNNING IN DRY-RUN MODE - No changes will be made"
        Write-Host ""
    }
}

function Write-Log {
    param([string]$Message)
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Host "[${timestamp}] $Message" -ForegroundColor Green
}

function Write-InfoLog {
    param([string]$Message)
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Host "[${timestamp}] INFO: $Message" -ForegroundColor Cyan
}

function Write-WarnLog {
    param([string]$Message)
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Warning "[${timestamp}] WARNING: $Message"
}

function Write-ErrorLog {
    param(
        [string]$Message,
        [switch]$Fatal
    )
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Host "[${timestamp}] ERROR: $Message" -ForegroundColor Red
    
    $script:Errors += $Message
    
    if ($Fatal) {
        Write-Host ""
        Write-Host "Fatal error encountered. Exiting." -ForegroundColor Red
        Write-Host "Check log file for details: $script:LogFile" -ForegroundColor Yellow
        Stop-Transcript
        exit 1
    }
}

function Write-Success {
    param([string]$Message)
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Host "[${timestamp}] SUCCESS: $Message" -ForegroundColor Green
}

# ============================================================================
# PREREQUISITE CHECKS
# ============================================================================

function Test-Prerequisites {
    Write-Log "Checking prerequisites..."
    
    $allPassed = $true
    
    # Check PowerShell version
    $psVersion = $PSVersionTable.PSVersion
    if ($psVersion.Major -lt 5) {
        Write-ErrorLog "PowerShell 5.1 or higher is required. Current version: $psVersion"
        $allPassed = $false
    } else {
        Write-Success "PowerShell version: $psVersion"
    }
    
    # Check if Azure CLI is installed
    try {
        $azVersion = az version --output json | ConvertFrom-Json
        Write-Success "Azure CLI version: $($azVersion.'azure-cli')"
    } catch {
        Write-ErrorLog "Azure CLI is not installed or not in PATH" -Fatal
    }
    
    # Check if kubectl is accessible
    try {
        $kubectlVersion = kubectl version --client --output=json 2>$null | ConvertFrom-Json
        Write-Success "kubectl version: $($kubectlVersion.clientVersion.gitVersion)"
    } catch {
        Write-WarnLog "kubectl not found. Will need to configure from cluster_info.json"
    }
    
    # Check if cluster_info.json exists
    if ([System.IO.Path]::IsPathRooted($ClusterInfo)) { 
        $clusterInfoPath = $ClusterInfo
    } else {
        # Check edge_configs folder first, then linux_build folder
        $searchPaths = @(
            (Join-Path $script:ScriptDir "edge_configs\$ClusterInfo"),
            (Join-Path $script:ScriptDir $ClusterInfo)
        )
        
        $clusterInfoPath = $null
        foreach ($path in $searchPaths) {
            if (Test-Path $path) {
                $clusterInfoPath = $path
                break
            }
        }
        
        if (-not $clusterInfoPath) {
            $clusterInfoPath = Join-Path $script:ScriptDir $ClusterInfo
        }
    }
    
    if (-not (Test-Path $clusterInfoPath)) {
        Write-ErrorLog "Cluster info file not found: $clusterInfoPath" -Fatal
    } else {
        Write-Success "Cluster info file found: $clusterInfoPath"
    }
    
    if (-not $allPassed) {
        Write-ErrorLog "Prerequisite checks failed" -Fatal
    }
    
    Write-Success "All prerequisites passed"
}

# ============================================================================
# CONFIGURATION LOADING
# ============================================================================

function Import-ClusterInfo {
    Write-Log "Loading cluster information..."
    
    $clusterInfoPath = $null
    
    if ([System.IO.Path]::IsPathRooted($ClusterInfo)) { 
        $clusterInfoPath = $ClusterInfo
    } else {
        # Check edge_configs folder first, then linux_build folder
        $searchPaths = @(
            (Join-Path $script:ScriptDir "edge_configs\$ClusterInfo"),
            (Join-Path $script:ScriptDir $ClusterInfo)
        )
        
        Write-InfoLog "Searching for cluster_info.json..."
        foreach ($path in $searchPaths) {
            Write-InfoLog "Checking: $path"
            if (Test-Path $path) {
                $clusterInfoPath = $path
                Write-Success "Found cluster info at: $path"
                break
            }
        }
        
        if (-not $clusterInfoPath) {
            Write-Host ""
            Write-ErrorLog "Cluster info file 'cluster_info.json' not found in expected locations:"
            foreach ($path in $searchPaths) {
                Write-Host "  - $path" -ForegroundColor Gray
            }
            Write-Host ""
            Write-Host "To generate cluster_info.json:" -ForegroundColor Yellow
            Write-Host "  1. Run linux_installer.sh on your edge device" -ForegroundColor Gray
            Write-Host "  2. Copy the generated cluster_info.json from the edge device" -ForegroundColor Gray
            Write-Host "  3. Place it in: $($searchPaths[0])" -ForegroundColor Gray
            Write-Host "     or: $($searchPaths[1])" -ForegroundColor Gray
            Write-Host ""
            Write-ErrorLog "cluster_info.json is required. Exiting." -Fatal
        }
    }
    
    if (-not (Test-Path $clusterInfoPath)) {
        Write-ErrorLog "Cluster info file not found: $clusterInfoPath" -Fatal
    }
    
    try {
        $script:ClusterData = Get-Content $clusterInfoPath -Raw | ConvertFrom-Json
        
        Write-Host ""
        Write-Host "Cluster Information:" -ForegroundColor Cyan
        Write-Host "  Cluster Name: $($script:ClusterData.cluster_name)" -ForegroundColor Gray
        Write-Host "  Node Name: $($script:ClusterData.node_name)" -ForegroundColor Gray
        Write-Host "  Kubernetes Version: $($script:ClusterData.kubernetes_version)" -ForegroundColor Gray
        Write-Host "  Node OS: $($script:ClusterData.node_os)" -ForegroundColor Gray
        Write-Host "  Timestamp: $($script:ClusterData.timestamp)" -ForegroundColor Gray
        Write-Host "  Ready for Arc: $($script:ClusterData.ready_for_arc)" -ForegroundColor Gray
        
        if ($script:ClusterData.deployed_modules -and $script:ClusterData.deployed_modules.Count -gt 0) {
            Write-Host "  Deployed Modules: $($script:ClusterData.deployed_modules -join ', ')" -ForegroundColor Gray
        }
        
        if ($script:ClusterData.installed_tools -and $script:ClusterData.installed_tools.Count -gt 0) {
            Write-Host "  Installed Tools: $($script:ClusterData.installed_tools -join ', ')" -ForegroundColor Gray
        }
        Write-Host ""
        
        # Set cluster name from cluster info
        $script:ClusterName = $script:ClusterData.cluster_name
        
        Write-Success "Cluster information loaded successfully"
    } catch {
        Write-ErrorLog "Failed to parse cluster info file: $_" -Fatal
    }
}

function Import-AzureConfig {
    $configPath = $null
    
    # If ConfigFile parameter is provided, use it
    if ($ConfigFile) {
        if ([System.IO.Path]::IsPathRooted($ConfigFile)) { 
            $configPath = $ConfigFile 
        } else { 
            $configPath = Join-Path $script:ScriptDir $ConfigFile 
        }
        
        if (-not (Test-Path $configPath)) {
            Write-ErrorLog "Specified config file not found: $configPath" -Fatal
        }
        
        Write-Log "Loading configuration from $configPath..."
    } else {
        # Search for linux_aio_config.json in expected locations
        $searchPaths = @(
            (Join-Path $script:ScriptDir "edge_configs\linux_aio_config.json"),
            (Join-Path $script:ScriptDir "linux_aio_config.json")
        )
        
        Write-Log "Searching for linux_aio_config.json..."
        
        foreach ($path in $searchPaths) {
            Write-InfoLog "Checking: $path"
            if (Test-Path $path) {
                $configPath = $path
                Write-Success "Found configuration at: $path"
                break
            }
        }
        
        if (-not $configPath) {
            Write-Host ""
            Write-WarnLog "Configuration file 'linux_aio_config.json' not found in expected locations:"
            foreach ($path in $searchPaths) {
                Write-Host "  - $path" -ForegroundColor Gray
            }
            Write-Host ""
            Write-Host "To use this configurator, you need to:" -ForegroundColor Yellow
            Write-Host "  1. Run linux_installer.sh on your edge device" -ForegroundColor Gray
            Write-Host "  2. Copy the generated linux_aio_config.json file from the edge device" -ForegroundColor Gray
            Write-Host "  3. Place it in one of these locations:" -ForegroundColor Gray
            Write-Host "     - $($searchPaths[0])" -ForegroundColor Gray
            Write-Host "     - $($searchPaths[1])" -ForegroundColor Gray
            Write-Host ""
            Write-Host "Alternatively, you can:" -ForegroundColor Yellow
            Write-Host "  - Specify a custom config file: -ConfigFile 'path\to\config.json'" -ForegroundColor Gray
            Write-Host "  - Continue in interactive mode (you will be prompted for values)" -ForegroundColor Gray
            Write-Host ""
            
            $continue = Read-Host "Continue in interactive mode? (y/n)"
            if ($continue -ne 'y') {
                Write-ErrorLog "Configuration file required. Exiting." -Fatal
            }
            
            Write-InfoLog "Using interactive configuration mode"
            return
        }
    }
    
    try {
        $script:AzureConfig = Get-Content $configPath -Raw | ConvertFrom-Json
        
        # Load Azure settings
        $script:SubscriptionId = $script:AzureConfig.azure.subscription_id
        $script:SubscriptionName = $script:AzureConfig.azure.subscription_name
        $script:ResourceGroup = $script:AzureConfig.azure.resource_group
        $script:Location = $script:AzureConfig.azure.location
        $script:NamespaceName = $script:AzureConfig.azure.namespace_name
        
        # Override cluster name from config if provided
        if ($script:AzureConfig.azure.cluster_name) {
            $script:ClusterName = $script:AzureConfig.azure.cluster_name
        }
        
        # Load deployment settings
        if ($script:AzureConfig.deployment) {
            $script:DeploymentMode = if ($script:AzureConfig.deployment.deployment_mode) { $script:AzureConfig.deployment.deployment_mode } else { "production" }
            $script:DeployMqttAssets = if ($null -ne $script:AzureConfig.deployment.deploy_mqtt_assets) { $script:AzureConfig.deployment.deploy_mqtt_assets } else { $true }
            $script:EnableResourceSync = if ($null -ne $script:AzureConfig.deployment.enable_resource_sync) { $script:AzureConfig.deployment.enable_resource_sync } else { $true }
        }
        
        Write-Success "Azure configuration loaded successfully"
    } catch {
        Write-ErrorLog "Failed to parse Azure config file: $_" -Fatal
    }
}

# ============================================================================
# AZURE AUTHENTICATION
# ============================================================================

function Connect-ToAzure {
    Write-Log "Checking Azure authentication..."
    
    # Check if already logged in
    try {
        $currentAccount = az account show 2>$null | ConvertFrom-Json
        if ($currentAccount) {
            Write-Success "Already logged into Azure"
            Write-InfoLog "Current subscription: $($currentAccount.name)"
            
            # Use current subscription if not specified in config
            if (-not $script:SubscriptionId) {
                $script:SubscriptionId = $currentAccount.id
                $script:SubscriptionName = $currentAccount.name
            }
        }
    } catch {
        Write-Log "Not currently logged into Azure. Initiating login..."
        
        if ($DryRun) {
            Write-InfoLog "[DRY-RUN] Would execute: az login"
            return
        }
        
        # Login to Azure
        az login
        
        # Get current subscription after login
        $currentAccount = az account show | ConvertFrom-Json
        if (-not $script:SubscriptionId) {
            $script:SubscriptionId = $currentAccount.id
            $script:SubscriptionName = $currentAccount.name
        }
    }
    
    # Set subscription if specified and different from current
    $currentSubId = (az account show | ConvertFrom-Json).id
    if ($script:SubscriptionId -and ($script:SubscriptionId -ne $currentSubId)) {
        Write-Log "Setting subscription to: $script:SubscriptionId"
        
        if ($DryRun) {
            Write-InfoLog "[DRY-RUN] Would execute: az account set --subscription $script:SubscriptionId"
        } else {
            az account set --subscription $script:SubscriptionId
        }
    }
    
    # Get final subscription details
    $currentAccount = az account show | ConvertFrom-Json
    $script:SubscriptionId = $currentAccount.id
    $script:SubscriptionName = $currentAccount.name
    
    # Prompt for missing configuration values
    if (-not $script:ResourceGroup) {
        $script:ResourceGroup = Read-Host "Enter resource group name (will be created if it does not exist)"
    }
    
    if (-not $script:Location) {
        $script:Location = Read-Host "Enter Azure region (e.g. eastus or westus2 or westeurope)"
    }
    
    if (-not $script:NamespaceName) {
        $script:NamespaceName = Read-Host "Enter namespace name for Azure Device Registry"
    }
    
    Write-Host ""
    Write-Host "Azure Configuration:" -ForegroundColor Cyan
    Write-Host "  Subscription: $script:SubscriptionName" -ForegroundColor Gray
    Write-Host "  Subscription ID: $script:SubscriptionId" -ForegroundColor Gray
    Write-Host "  Resource Group: $script:ResourceGroup" -ForegroundColor Gray
    Write-Host "  Location: $script:Location" -ForegroundColor Gray
    Write-Host "  Cluster Name: $script:ClusterName" -ForegroundColor Gray
    Write-Host "  Namespace: $script:NamespaceName" -ForegroundColor Gray
    Write-Host ""
    
    Write-Success "Azure authentication configured"
}

# ============================================================================
# KUBECONFIG SETUP
# ============================================================================

function Initialize-KubeConfig {
    Write-Log "Configuring kubectl for remote cluster access..."
    
    if (-not $script:ClusterData.kubeconfig_base64) {
        Write-ErrorLog "No kubeconfig data found in cluster_info.json" -Fatal
    }
    
    try {
        # Decode base64 kubeconfig
        $kubeconfigBytes = [System.Convert]::FromBase64String($script:ClusterData.kubeconfig_base64)
        $kubeconfigContent = [System.Text.Encoding]::UTF8.GetString($kubeconfigBytes)
        
        # Check if kubeconfig uses localhost and needs to be updated
        if ($kubeconfigContent -match 'server:\s*https?://127\.0\.0\.1:') {
            Write-WarnLog "Kubeconfig uses localhost (127.0.0.1) which won't work from a remote machine"
            
            # Try to get IP from cluster_info.json first
            $edgeDeviceAddress = $null
            if ($script:ClusterData.node_ip) {
                $edgeDeviceAddress = $script:ClusterData.node_ip
                Write-InfoLog "Using node IP from cluster_info.json: $edgeDeviceAddress"
            } else {
                # Prompt user for IP address
                Write-Host ""
                Write-Host "Please enter the IP address or hostname of your edge device ($($script:ClusterData.node_name)):" -ForegroundColor Yellow
                $edgeDeviceAddress = Read-Host "Edge device IP/hostname"
            }
            
            if (-not $edgeDeviceAddress) {
                Write-ErrorLog "Edge device address is required for remote cluster access" -Fatal
            }
            
            # Replace localhost with actual edge device address
            $kubeconfigContent = $kubeconfigContent -replace 'server:\s*https?://127\.0\.0\.1:', "server: https://${edgeDeviceAddress}:"
            Write-Success "Updated kubeconfig server address to: https://${edgeDeviceAddress}:6443"
        }
        
        # Save to temporary location
        $tempKubeConfig = Join-Path $env:TEMP "kubeconfig_$($script:ClusterName).yaml"
        Set-Content -Path $tempKubeConfig -Value $kubeconfigContent -NoNewline
        
        # Set KUBECONFIG environment variable for this session
        $env:KUBECONFIG = $tempKubeConfig
        
        Write-Success "Kubeconfig configured at: $tempKubeConfig"
        
        # Test connectivity
        Write-Log "Testing cluster connectivity..."
        $nodes = kubectl get nodes --no-headers 2>&1
        if ($LASTEXITCODE -ne 0) {
            Write-ErrorLog "Cannot connect to cluster. Please ensure network connectivity to edge device."
            Write-ErrorLog "Error: $nodes"
            Write-Host ""
            Write-Host "Troubleshooting tips:" -ForegroundColor Yellow
            Write-Host "  1. Verify the edge device IP/hostname is correct" -ForegroundColor Gray
            Write-Host "  2. Ensure port 6443 is accessible (check firewall on edge device)" -ForegroundColor Gray
            Write-Host "  3. Test connectivity: Test-NetConnection -ComputerName <edge-ip> -Port 6443" -ForegroundColor Gray
            Write-Host "  4. On edge device, allow port: sudo ufw allow 6443/tcp" -ForegroundColor Gray
            Write-Host ""
            Write-ErrorLog "Cannot establish connection to cluster" -Fatal
        }
        
        Write-Success "Successfully connected to cluster"
        kubectl get nodes
        
    } catch {
        Write-ErrorLog "Failed to configure kubeconfig: $_"
        
        # Check if kubectl is the issue
        if ($_.Exception.Message -like "*'kubectl' is not recognized*") {
            Write-Host ""
            Write-Host "kubectl is required but not found in PATH." -ForegroundColor Yellow
            Write-Host ""
            Write-Host "OPTION 1 - Using Azure CLI:" -ForegroundColor Cyan
            Write-Host "  Run: az aks install-cli" -ForegroundColor White
            Write-Host "  Then add to PATH:" -ForegroundColor Gray
            Write-Host "    `$env:Path += `";`$HOME\.azure-kubectl`"" -ForegroundColor White
            Write-Host "    [Environment]::SetEnvironmentVariable('Path', `$env:Path, 'User')" -ForegroundColor White
            Write-Host ""
            Write-Host "OPTION 2 - Using winget (handles PATH automatically):" -ForegroundColor Cyan
            Write-Host "  winget install -e --id Kubernetes.kubectl" -ForegroundColor White
            Write-Host ""
            Write-Host "OPTION 3 - Using Chocolatey (handles PATH automatically):" -ForegroundColor Cyan
            Write-Host "  choco install kubernetes-cli" -ForegroundColor White
            Write-Host ""
            Write-Host "After installation, close and reopen PowerShell, then run this script again." -ForegroundColor Yellow
            Write-Host ""
        }
        
        Write-ErrorLog "kubectl configuration failed" -Fatal
    }
}

# ============================================================================
# AZURE RESOURCE CREATION
# ============================================================================

function New-AzureResources {
    Write-Log "Creating Azure resources..."
    
    # Create resource group if it does not exist
    Write-Log "Checking resource group: $script:ResourceGroup"
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Would check/create resource group: $script:ResourceGroup"
        return
    }
    
    $rgExists = az group exists --name $script:ResourceGroup | ConvertFrom-Json
    
    if (-not $rgExists) {
        Write-Log "Creating resource group: $script:ResourceGroup in $script:Location"
        az group create --location $script:Location --resource-group $script:ResourceGroup --output none
        Write-Success "Resource group created: $script:ResourceGroup"
        $script:DeployedResources += "ResourceGroup:$script:ResourceGroup"
    } else {
        Write-Success "Resource group already exists: $script:ResourceGroup"
    }
}

# ============================================================================
# ARC ENABLEMENT
# ============================================================================

function Enable-ArcForCluster {
    if ($SkipArcEnable) {
        Write-InfoLog "Skipping Arc enablement (-SkipArcEnable flag)"
        return
    }
    
    Write-Log "Connecting cluster to Azure Arc..."
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Would Arc-enable cluster: $script:ClusterName"
        return
    }
    
    # Check if cluster is already Arc-enabled
    $arcCluster = az connectedk8s show --name $script:ClusterName --resource-group $script:ResourceGroup 2>$null
    
    if ($arcCluster) {
        Write-Success "Cluster $script:ClusterName is already Arc-enabled"
    } else {
        Write-Log "Connecting cluster to Azure Arc..."
        az connectedk8s connect --name $script:ClusterName --resource-group $script:ResourceGroup
        
        if ($LASTEXITCODE -ne 0) {
            Write-ErrorLog "Failed to Arc-enable cluster" -Fatal
        }
        
        Write-Success "Cluster Arc-enabled successfully"
        $script:DeployedResources += "ConnectedCluster:$script:ClusterName"
    }
    
    # Get OBJECT_ID for custom locations
    Write-Log "Getting Object ID for custom locations..."
    $objectId = az ad sp show --id bc313c14-388c-4e7d-a58e-70017303ee3b --query id -o tsv 2>$null
    
    if (-not $objectId) {
        Write-WarnLog "Could not retrieve custom locations service principal OID"
    } else {
        Write-InfoLog "Custom locations OID: $objectId"
        
        # Enable custom locations and cluster connect features
        Write-Log "Enabling custom locations and cluster connect features..."
        az connectedk8s enable-features `
            --name $script:ClusterName `
            --resource-group $script:ResourceGroup `
            --custom-locations-oid $objectId `
            --features cluster-connect custom-locations
        
        Write-Success "Custom locations and cluster connect enabled"
    }
    
    # Note: K3s restart is handled on the edge device, not from here
    Write-InfoLog "Note: If cluster connectivity issues occur, restart K3s on the edge device: sudo systemctl restart k3s"
}

# ============================================================================
# AZURE IOT OPERATIONS DEPLOYMENT
# ============================================================================

function New-IoTOperationsInstance {
    Write-Log "Deploying Azure IoT Operations..."
    
    $instanceName = "$script:ClusterName-aio"
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Would deploy Azure IoT Operations instance: $instanceName"
        return
    }
    
    # Check if instance already exists
    $existingInstance = az iot ops show --name $instanceName --resource-group $script:ResourceGroup 2>$null
    
    if ($existingInstance) {
        Write-Success "Azure IoT Operations instance $instanceName already exists"
        Write-InfoLog "To redeploy, delete the existing instance first:"
        Write-InfoLog "az iot ops delete --name $instanceName --resource-group $script:ResourceGroup"
        return
    }
    
    # Initialize cluster for Azure IoT Operations
    Write-Log "Initializing cluster for Azure IoT Operations..."
    az iot ops init --cluster $script:ClusterName --resource-group $script:ResourceGroup
    
    # Ensure Microsoft.Storage provider is registered
    Write-Log "Checking Azure resource provider registrations..."
    $storageProvider = az provider show --namespace Microsoft.Storage --query "registrationState" -o tsv 2>$null
    
    if ($storageProvider -ne "Registered") {
        Write-Log "Registering Microsoft.Storage resource provider..."
        az provider register --namespace Microsoft.Storage
        
        # Wait for registration
        Write-Log "Waiting for Microsoft.Storage provider registration..."
        do {
            Start-Sleep -Seconds 10
            $storageProvider = az provider show --namespace Microsoft.Storage --query registrationState -o tsv
            Write-InfoLog "Registration state: $storageProvider"
        } while ($storageProvider -ne "Registered")
        
        Write-Success "Microsoft.Storage provider registered"
    }
    
    # Create schema registry
    $schemaRegistryName = "$script:ClusterName-schema-registry"
    $storageAccountName = ($script:ClusterName + "storage").ToLower() -replace '[^a-z0-9]', '' | Select-Object -First 24
    
    New-SchemaRegistry -SchemaRegistryName $schemaRegistryName -StorageAccountName $storageAccountName
    
    # Get schema registry resource ID
    $schemaRegistryId = az iot ops schema registry show `
        --name $schemaRegistryName `
        --resource-group $script:ResourceGroup `
        --query id -o tsv
    
    # Create or verify Device Registry namespace
    New-DeviceRegistryNamespace
    
    # Construct namespace resource ID
    $namespaceResourceId = "/subscriptions/$script:SubscriptionId/resourceGroups/$script:ResourceGroup/providers/Microsoft.DeviceRegistry/namespaces/$script:NamespaceName"
    
    Write-Log "Using namespace resource ID: $namespaceResourceId"
    Write-Log "Using schema registry ID: $schemaRegistryId"
    
    # Deploy Azure IoT Operations
    Write-Log "Deploying Azure IoT Operations instance - this may take several minutes..."
    
    $deployResult = az iot ops create `
        --cluster $script:ClusterName `
        --resource-group $script:ResourceGroup `
        --name $instanceName `
        --sr-resource-id $schemaRegistryId `
        --ns-resource-id $namespaceResourceId 2>&1
    
    if ($LASTEXITCODE -ne 0) {
        Write-ErrorLog "Azure IoT Operations deployment failed"
        Write-ErrorLog "Error: $deployResult"
        Write-ErrorLog "Check Azure portal for more details" -Fatal
    }
    
    Write-Success "Azure IoT Operations deployed successfully!"
    $script:DeployedResources += "IoTOperationsInstance:$instanceName"
    
    # Enable resource sync
    if ($script:EnableResourceSync) {
        Enable-ResourceSync -InstanceName $instanceName
    }
}

function New-SchemaRegistry {
    param(
        [string]$SchemaRegistryName,
        [string]$StorageAccountName
    )
    
    Write-Log "Setting up schema registry..."
    
    # Check if schema registry exists
    $existingRegistry = az iot ops schema registry show `
        --name $SchemaRegistryName `
        --resource-group $script:ResourceGroup 2>$null
    
    if ($existingRegistry) {
        Write-Success "Schema registry $SchemaRegistryName already exists"
        return
    }
    
    # Create storage account
    Write-Log "Creating storage account: $StorageAccountName"
    
    $existingStorage = az storage account show `
        --name $StorageAccountName `
        --resource-group $script:ResourceGroup 2>$null
    
    if (-not $existingStorage) {
        az storage account create `
            --name $StorageAccountName `
            --resource-group $script:ResourceGroup `
            --location $script:Location `
            --sku Standard_LRS `
            --kind StorageV2 `
            --enable-hierarchical-namespace true `
            --allow-blob-public-access false `
            --output none
        
        Write-Success "Storage account created: $StorageAccountName"
    } else {
        Write-Success "Storage account already exists: $StorageAccountName"
    }
    
    # Create container
    $containerName = "schemas"
    Write-Log "Creating storage container: $containerName"
    
    $containerExists = az storage container exists `
        --name $containerName `
        --account-name $StorageAccountName `
        --auth-mode login `
        --query exists -o tsv 2>$null
    
    if ($containerExists -ne "true") {
        az storage container create `
            --name $containerName `
            --account-name $StorageAccountName `
            --auth-mode login `
            --output none
        
        Write-Success "Storage container created: $containerName"
    } else {
        Write-Success "Storage container already exists: $containerName"
    }
    
    # Get storage account resource ID
    $storageAccountId = az storage account show `
        --name $StorageAccountName `
        --resource-group $script:ResourceGroup `
        --query id -o tsv
    
    # Create schema registry
    Write-Log "Creating schema registry: $SchemaRegistryName"
    
    az iot ops schema registry create `
        --name $SchemaRegistryName `
        --resource-group $script:ResourceGroup `
        --registry-namespace $script:NamespaceName `
        --sa-resource-id $storageAccountId `
        --output none
    
    Write-Success "Schema registry created: $SchemaRegistryName"
    $script:DeployedResources += "SchemaRegistry:$SchemaRegistryName"
}

function New-DeviceRegistryNamespace {
    Write-Log "Configuring Device Registry namespace..."
    
    $namespaceResourceId = "/subscriptions/$script:SubscriptionId/resourceGroups/$script:ResourceGroup/providers/Microsoft.DeviceRegistry/namespaces/$script:NamespaceName"
    
    # Check if namespace exists
    $namespaceExists = az resource show --ids $namespaceResourceId 2>$null
    
    if ($namespaceExists) {
        Write-Success "Device Registry namespace already exists: $script:NamespaceName"
        return
    }
    
    Write-Log "Creating Device Registry namespace: $script:NamespaceName"
    
    $createResult = az deviceregistry namespace create `
        --name $script:NamespaceName `
        --resource-group $script:ResourceGroup `
        --location $script:Location 2>&1
    
    if ($LASTEXITCODE -ne 0) {
        Write-ErrorLog "Failed to create Device Registry namespace"
        Write-ErrorLog "Error: $createResult"
        Write-InfoLog "You can try creating it manually with:"
        Write-InfoLog "az deviceregistry namespace create --name $script:NamespaceName --resource-group $script:ResourceGroup --location $script:Location"
        Write-ErrorLog "Device Registry namespace is required for Azure IoT Operations" -Fatal
    }
    
    Write-Success "Device Registry namespace created: $script:NamespaceName"
    $script:DeployedResources += "DeviceRegistryNamespace:$script:NamespaceName"
}

function Enable-ResourceSync {
    param([string]$InstanceName)
    
    Write-Log "Enabling edge-to-cloud asset sync..."
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Would enable resource sync for: $InstanceName"
        return
    }
    
    $rsyncResult = az iot ops enable-rsync `
        --name $InstanceName `
        --resource-group $script:ResourceGroup 2>&1
    
    if ($LASTEXITCODE -ne 0) {
        Write-WarnLog "Failed to enable asset sync automatically"
        Write-InfoLog "You can enable it manually later with:"
        Write-InfoLog "az iot ops enable-rsync --name $InstanceName --resource-group $script:ResourceGroup"
        
        # Try with explicit K8 Bridge service principal OID
        Write-Log "Attempting with explicit K8 Bridge service principal OID..."
        $k8BridgeOid = az ad sp list --display-name "K8 Bridge" --query "[0].id" -o tsv 2>$null
        
        if ($k8BridgeOid) {
            Write-InfoLog "Found K8 Bridge service principal OID: $k8BridgeOid"
            
            $rsyncResult = az iot ops enable-rsync `
                --name $InstanceName `
                --resource-group $script:ResourceGroup `
                --k8-bridge-sp-oid $k8BridgeOid 2>&1
            
            if ($LASTEXITCODE -eq 0) {
                Write-Success "Asset sync enabled successfully with explicit OID"
            } else {
                Write-WarnLog "Failed to enable asset sync even with explicit OID"
                Write-WarnLog "Manual intervention may be required"
            }
        } else {
            Write-WarnLog "Could not retrieve K8 Bridge service principal OID"
        }
    } else {
        Write-Success "Asset sync enabled successfully!"
        Write-InfoLog "Discovered assets on the edge will now be surfaced in the cloud"
    }
}

# ============================================================================
# VERIFICATION
# ============================================================================

function Test-Deployment {
    if ($SkipVerification) {
        Write-InfoLog "Skipping deployment verification (-SkipVerification flag)"
        return
    }
    
    Write-Log "Verifying deployment..."
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Would verify deployment"
        return
    }
    
    # Verify resource group
    $rgExists = az group exists --name $script:ResourceGroup | ConvertFrom-Json
    if (-not $rgExists) {
        Write-ErrorLog "Resource group not found: $script:ResourceGroup"
        return
    }
    Write-Success "Resource group verified: $script:ResourceGroup"
    
    # Verify Arc connection
    if (-not $SkipArcEnable) {
        $arcCluster = az connectedk8s show --name $script:ClusterName --resource-group $script:ResourceGroup 2>$null
        if ($arcCluster) {
            $arcData = $arcCluster | ConvertFrom-Json
            Write-Success "Arc-enabled cluster verified: $script:ClusterName (State: $($arcData.connectivityStatus))"
        } else {
            Write-WarnLog "Arc-enabled cluster not found: $script:ClusterName"
        }
    }
    
    # Verify IoT Operations instance
    $instanceName = "$script:ClusterName-aio"
    $iotOps = az iot ops show --name $instanceName --resource-group $script:ResourceGroup 2>$null
    
    if ($iotOps) {
        $iotOpsData = $iotOps | ConvertFrom-Json
        Write-Success "Azure IoT Operations instance verified: $instanceName (State: $($iotOpsData.provisioningState))"
    } else {
        Write-WarnLog "Azure IoT Operations instance not found: $instanceName"
    }
    
    # Check cluster pods
    Write-Log "Checking cluster resources..."
    kubectl get pods --all-namespaces
    
    Write-Success "Deployment verification completed"
}

# ============================================================================
# DEPLOYMENT SUMMARY
# ============================================================================

function Export-DeploymentSummary {
    Write-Log "Generating deployment summary..."
    
    $summary = @{
        timestamp = Get-Date -Format "o"
        cluster_name = $script:ClusterName
        azure = @{
            subscription_id = $script:SubscriptionId
            subscription_name = $script:SubscriptionName
            resource_group = $script:ResourceGroup
            location = $script:Location
            namespace_name = $script:NamespaceName
        }
        deployment = @{
            deployment_mode = $script:DeploymentMode
            deployed_resources = $script:DeployedResources
            errors = $script:Errors
        }
        configurator_version = "1.0.0"
        dry_run = $DryRun.IsPresent
    }
    
    # Add cluster info if available
    if ($script:ClusterData) {
        $summary.cluster = @{
            node_name = $script:ClusterData.node_name
            kubernetes_version = $script:ClusterData.kubernetes_version
            node_os = $script:ClusterData.node_os
            deployed_modules = $script:ClusterData.deployed_modules
            installed_tools = $script:ClusterData.installed_tools
        }
    }
    
    $summary | ConvertTo-Json -Depth 10 | Set-Content -Path $script:DeploymentSummaryFile
    
    Write-Success "Deployment summary saved to: $script:DeploymentSummaryFile"
}

# ============================================================================
# FINAL SUMMARY DISPLAY
# ============================================================================

function Show-CompletionSummary {
    Write-Host ""
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host "Azure IoT Operations Configuration Completed!" -ForegroundColor Cyan
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host ""
    
    Write-Host "Deployed Resources:" -ForegroundColor Green
    foreach ($resource in $script:DeployedResources) {
        Write-Host "  + $resource" -ForegroundColor Gray
    }
    Write-Host ""
    
    if ($script:Errors.Count -gt 0) {
        Write-Host "Errors Encountered:" -ForegroundColor Red
        foreach ($errors in $script:Errors) {
            Write-Host "  - $errors" -ForegroundColor Gray
        }
        Write-Host ""
    }
    
    Write-Host "Azure Resources:" -ForegroundColor Cyan
    Write-Host "  Subscription: $script:SubscriptionName ($script:SubscriptionId)" -ForegroundColor Gray
    Write-Host "  Resource Group: $script:ResourceGroup" -ForegroundColor Gray
    Write-Host "  Location: $script:Location" -ForegroundColor Gray
    Write-Host "  IoT Operations Instance: $($script:ClusterName)-aio" -ForegroundColor Gray
    Write-Host ""
    Write-Host "View in Azure Portal: https://portal.azure.com" -ForegroundColor Cyan
    Write-Host ""
    
    Write-Host "Next Steps:" -ForegroundColor Green
    Write-Host "  1. View deployment summary: cat `$script:DeploymentSummaryFile" -ForegroundColor Gray
    Write-Host "  2. Monitor cluster: kubectl get pods -A" -ForegroundColor Gray
    Write-Host "  3. Check Azure portal for resource status" -ForegroundColor Gray
    Write-Host "  4. Deploy MQTT assets (if applicable)" -ForegroundColor Gray
    Write-Host ""
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host ""
    
    if ($DryRun) {
        Write-Host "NOTE: This was a DRY-RUN. No actual changes were made." -ForegroundColor Yellow
        Write-Host ""
    }
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

function Main {
    try {
        # Initialize logging
        Initialize-Logging
        
        Write-Log "Starting Azure IoT Operations External Configurator"
        Write-Log "Version: 1.0.0 (Separation of Concerns)"
        Write-Host ""
        
        # Phase 1: Prerequisites and Configuration
        Test-Prerequisites
        Import-ClusterInfo
        Import-AzureConfig
        
        # Phase 2: Azure Authentication
        Connect-ToAzure
        
        # Phase 3: Cluster Connectivity
        Initialize-KubeConfig
        
        # Phase 4: Azure Resource Creation
        New-AzureResources
        
        # Phase 5: Arc Enablement
        Enable-ArcForCluster
        
        # Phase 6: IoT Operations Deployment
        New-IoTOperationsInstance
        
        # Phase 7: Verification
        Test-Deployment
        
        # Phase 8: Summary
        Export-DeploymentSummary
        Show-CompletionSummary
        
        Write-Success "External configuration completed successfully!"
        
    } catch {
        Write-ErrorLog "Unexpected error: $_"
        Write-ErrorLog $_.ScriptStackTrace
        
        if ($script:Errors.Count -gt 0) {
            Write-Host ""
            Write-Host "Errors encountered during execution:" -ForegroundColor Red
            foreach ($err in $script:Errors) {
                Write-Host "  - $err" -ForegroundColor Gray
            }
        }
        
        throw
    } finally {
        Stop-Transcript
    }
}

# Run main function
Main
