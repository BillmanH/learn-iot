<#
.SYNOPSIS
    Azure IoT Operations - External Configurator (PowerShell)

.DESCRIPTION
    This script connects edge K3s clusters to Azure Arc and deploys Azure IoT Operations.
    It runs on a Windows management machine with Azure CLI and deploys infrastructure 
    using ARM templates for Infrastructure as Code (IaC).
    
    Requirements:
    - Windows 10/11 or Windows Server 2019+
    - PowerShell 5.1+ or PowerShell 7+
    - Azure CLI installed with iot-ops extension
    - Azure credentials with appropriate permissions
    - cluster_info.json from installer.sh (in config/ folder)
    
.PARAMETER ConfigFile
    Path to configuration file (default: config/aio_config.json)
    
.PARAMETER ClusterInfo
    Path to cluster_info.json file generated by installer.sh (default: config/cluster_info.json)
    
.PARAMETER DryRun
    Validate configuration and show what-if without making changes
    
.PARAMETER SkipArcEnable
    Skip Arc-enabling the cluster (useful if already Arc-enabled)
    
.PARAMETER SkipIoTOps
    Skip Azure IoT Operations deployment (deploy infrastructure only)

.PARAMETER SkipVerification
    Skip post-deployment verification
    
.EXAMPLE
    .\External-Configurator.ps1
    
.EXAMPLE
    .\External-Configurator.ps1 -DryRun
    
.EXAMPLE
    .\External-Configurator.ps1 -ConfigFile ..\config\aio_config.json -SkipArcEnable
    
.NOTES
    Author: Azure IoT Operations Team
    Date: January 2026
    Version: 2.0.0 - ARM Template Based Deployment
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [string]$ConfigFile = "",
    
    [Parameter(Mandatory=$false)]
    [string]$ClusterInfo = "",
    
    [Parameter(Mandatory=$false)]
    [switch]$DryRun,
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipArcEnable,
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipIoTOps,
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipVerification
)

# ============================================================================
# GLOBAL VARIABLES
# ============================================================================

$script:ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$script:RepoRoot = Split-Path -Parent $script:ScriptDir
$script:ConfigDir = Join-Path $script:RepoRoot "config"
$script:ArmTemplatesDir = Join-Path $script:RepoRoot "arm_templates"
$script:LogFile = Join-Path $script:ScriptDir "external_configurator_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
$script:DeploymentSummaryFile = Join-Path $script:ConfigDir "deployment_summary.json"

# Configuration variables (loaded from files)
$script:ClusterData = $null
$script:AzureConfig = $null
$script:SubscriptionId = $null
$script:SubscriptionName = $null
$script:ResourceGroup = $null
$script:Location = $null
$script:ClusterName = $null
$script:ConfigClusterName = $null  # Cluster name from aio_config.json (for validation)
$script:NamespaceName = $null
$script:KeyVaultName = $null
$script:StorageAccountName = $null
$script:SchemaRegistryName = $null

# Deployment tracking
$script:DeployedResources = @()
$script:Errors = @()

# ============================================================================
# LOGGING FUNCTIONS
# ============================================================================

function Initialize-Logging {
    Start-Transcript -Path $script:LogFile -Append
    
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host "Azure IoT Operations - External Configurator v2.0" -ForegroundColor Cyan
    Write-Host "ARM Template Based Deployment" -ForegroundColor Cyan
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host "Log file: $script:LogFile" -ForegroundColor Gray
    Write-Host "Started: $(Get-Date)" -ForegroundColor Gray
    Write-Host "Script directory: $script:ScriptDir" -ForegroundColor Gray
    Write-Host "ARM templates: $script:ArmTemplatesDir" -ForegroundColor Gray
    Write-Host ""
    
    if ($DryRun) {
        Write-Warning "RUNNING IN DRY-RUN MODE - Will use what-if validation only"
        Write-Host ""
    }
}

function Write-Log {
    param([string]$Message)
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Host "[${timestamp}] $Message" -ForegroundColor Green
}

function Write-InfoLog {
    param([string]$Message)
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Host "[${timestamp}] INFO: $Message" -ForegroundColor Cyan
}

function Write-WarnLog {
    param([string]$Message)
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Warning "[${timestamp}] WARNING: $Message"
}

function Write-ErrorLog {
    param(
        [string]$Message,
        [switch]$Fatal
    )
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Host "[${timestamp}] ERROR: $Message" -ForegroundColor Red
    
    $script:Errors += $Message
    
    if ($Fatal) {
        Write-Host ""
        Write-Host "Fatal error encountered. Exiting." -ForegroundColor Red
        Write-Host "Check log file for details: $script:LogFile" -ForegroundColor Yellow
        Stop-Transcript
        exit 1
    }
}

function Write-Success {
    param([string]$Message)
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Write-Host "[${timestamp}] SUCCESS: $Message" -ForegroundColor Green
}

# ============================================================================
# PREREQUISITE CHECKS
# ============================================================================

function Test-Prerequisites {
    Write-Log "Checking prerequisites..."
    
    $allPassed = $true
    
    # Check PowerShell version
    $psVersion = $PSVersionTable.PSVersion
    if ($psVersion.Major -lt 5) {
        Write-ErrorLog "PowerShell 5.1 or higher is required. Current version: $psVersion"
        $allPassed = $false
    } else {
        Write-Success "PowerShell version: $psVersion"
    }
    
    # Check if Azure CLI is installed
    try {
        $azVersion = az version --output json 2>$null | ConvertFrom-Json
        Write-Success "Azure CLI version: $($azVersion.'azure-cli')"
    } catch {
        Write-ErrorLog "Azure CLI is not installed or not in PATH" -Fatal
    }
    
    # Check for iot-ops extension
    $extensions = az extension list --output json 2>$null | ConvertFrom-Json
    $iotOpsExt = $extensions | Where-Object { $_.name -eq 'azure-iot-ops' }
    
    if (-not $iotOpsExt) {
        Write-WarnLog "azure-iot-ops extension not found. Installing..."
        az extension add --name azure-iot-ops --upgrade
        Write-Success "azure-iot-ops extension installed"
    } else {
        Write-Success "azure-iot-ops extension version: $($iotOpsExt.version)"
    }
    
    # Check ARM templates directory
    if (-not (Test-Path $script:ArmTemplatesDir)) {
        Write-ErrorLog "ARM templates directory not found: $script:ArmTemplatesDir" -Fatal
    }
    Write-Success "ARM templates directory found"
    
    # Check config directory
    if (-not (Test-Path $script:ConfigDir)) {
        Write-ErrorLog "Config directory not found: $script:ConfigDir" -Fatal
    }
    Write-Success "Config directory found"
    
    if (-not $allPassed) {
        Write-ErrorLog "Prerequisite checks failed" -Fatal
    }
    
    Write-Success "All prerequisites passed"
}

# ============================================================================
# CONFIGURATION LOADING
# ============================================================================

function Import-ClusterInfo {
    Write-Log "Loading cluster information..."
    
    # Determine cluster info path
    $clusterInfoPath = $null
    
    if ($ClusterInfo) {
        if ([System.IO.Path]::IsPathRooted($ClusterInfo)) {
            $clusterInfoPath = $ClusterInfo
        } else {
            $clusterInfoPath = Join-Path $script:ScriptDir $ClusterInfo
        }
    } else {
        # Default: look in config folder
        $clusterInfoPath = Join-Path $script:ConfigDir "cluster_info.json"
    }
    
    if (-not (Test-Path $clusterInfoPath)) {
        Write-ErrorLog "Cluster info file not found: $clusterInfoPath"
        Write-Host ""
        Write-Host "The cluster_info.json file is generated by the edge installer." -ForegroundColor Yellow
        Write-Host "Expected location: $clusterInfoPath" -ForegroundColor Yellow
        Write-Host ""
        Write-Host "Steps to resolve:" -ForegroundColor Cyan
        Write-Host "  1. Run installer.sh on your edge device" -ForegroundColor Gray
        Write-Host "  2. Copy config/cluster_info.json from the edge device to this machine" -ForegroundColor Gray
        Write-Host "  3. Place it in: $script:ConfigDir" -ForegroundColor Gray
        Write-ErrorLog "Cannot continue without cluster information" -Fatal
    }
    
    try {
        $script:ClusterData = Get-Content $clusterInfoPath -Raw | ConvertFrom-Json
        
        Write-Host ""
        Write-Host "Cluster Information:" -ForegroundColor Cyan
        Write-Host "  Cluster Name: $($script:ClusterData.cluster_name)" -ForegroundColor Gray
        Write-Host "  Node Name: $($script:ClusterData.node_name)" -ForegroundColor Gray
        Write-Host "  Node IP: $($script:ClusterData.node_ip)" -ForegroundColor Gray
        Write-Host "  Kubernetes Version: $($script:ClusterData.kubernetes_version)" -ForegroundColor Gray
        Write-Host "  Node OS: $($script:ClusterData.node_os)" -ForegroundColor Gray
        Write-Host "  Ready for Arc: $($script:ClusterData.ready_for_arc)" -ForegroundColor Gray
        Write-Host "  Installer Version: $($script:ClusterData.installer_version)" -ForegroundColor Gray
        Write-Host ""
        
        # Set cluster name from cluster info
        $script:ClusterName = $script:ClusterData.cluster_name
        
        Write-Success "Cluster information loaded from: $clusterInfoPath"
    } catch {
        Write-ErrorLog "Failed to parse cluster info file: $_" -Fatal
    }
}

function Import-AzureConfig {
    Write-Log "Loading Azure configuration..."
    
    # Determine config path
    $configPath = $null
    
    if ($ConfigFile) {
        if ([System.IO.Path]::IsPathRooted($ConfigFile)) {
            $configPath = $ConfigFile
        } else {
            $configPath = Join-Path $script:ScriptDir $ConfigFile
        }
    } else {
        # Default: look in config folder
        $configPath = Join-Path $script:ConfigDir "aio_config.json"
    }
    
    if (-not (Test-Path $configPath)) {
        Write-WarnLog "Config file not found: $configPath"
        Write-Host ""
        Write-Host "Configuration will be collected interactively." -ForegroundColor Yellow
        Write-Host "To use a config file, copy from template:" -ForegroundColor Yellow
        Write-Host "  cp config/quickstart_config.template config/aio_config.json" -ForegroundColor Gray
        Write-Host ""
        return
    }
    
    try {
        $script:AzureConfig = Get-Content $configPath -Raw | ConvertFrom-Json
        
        # Load Azure settings
        if ($script:AzureConfig.azure) {
            $script:SubscriptionId = $script:AzureConfig.azure.subscription_id
            $script:SubscriptionName = $script:AzureConfig.azure.subscription_name
            $script:ResourceGroup = $script:AzureConfig.azure.resource_group
            $script:Location = $script:AzureConfig.azure.location
            $script:NamespaceName = $script:AzureConfig.azure.namespace_name
            $script:KeyVaultName = $script:AzureConfig.azure.key_vault_name
            
            # Store the config cluster name for validation (don't override yet)
            $script:ConfigClusterName = $script:AzureConfig.azure.cluster_name
        }
        
        Write-Success "Azure configuration loaded from: $configPath"
    } catch {
        Write-ErrorLog "Failed to parse config file: $_"
        Write-WarnLog "Configuration will be collected interactively"
    }
}

function Test-ConfigConsistency {
    Write-Log "Validating configuration consistency..."
    
    # Check if both configs have cluster names defined
    $clusterInfoName = $script:ClusterData.cluster_name
    $aioConfigName = $script:ConfigClusterName
    
    if (-not $clusterInfoName) {
        Write-ErrorLog "cluster_info.json is missing cluster_name" -Fatal
    }
    
    if (-not $aioConfigName) {
        Write-InfoLog "aio_config.json does not specify cluster_name - using cluster_info.json value: $clusterInfoName"
        $script:ClusterName = $clusterInfoName
        return
    }
    
    # Both have cluster names - check if they match
    if ($clusterInfoName -ne $aioConfigName) {
        Write-Host ""
        Write-Host "============================================================================" -ForegroundColor Red
        Write-Host "WARNING: Cluster name mismatch detected!" -ForegroundColor Red
        Write-Host "============================================================================" -ForegroundColor Red
        Write-Host ""
        Write-Host "  cluster_info.json (from edge installer): $clusterInfoName" -ForegroundColor Yellow
        Write-Host "  aio_config.json (Azure config):          $aioConfigName" -ForegroundColor Yellow
        Write-Host ""
        Write-Host "This could indicate:" -ForegroundColor Cyan
        Write-Host "  - You're using the wrong config file for this cluster" -ForegroundColor Gray
        Write-Host "  - The aio_config.json was not updated after a fresh edge install" -ForegroundColor Gray
        Write-Host "  - These configs are for different environments" -ForegroundColor Gray
        Write-Host ""
        Write-Host "The cluster_info.json name comes from the actual edge device installer." -ForegroundColor Cyan
        Write-Host "The aio_config.json name is what will be used for Azure Arc registration." -ForegroundColor Cyan
        Write-Host ""
        
        Write-Host "Options:" -ForegroundColor Cyan
        Write-Host "  [1] Use cluster_info.json value: $clusterInfoName (recommended for fresh installs)" -ForegroundColor Gray
        Write-Host "  [2] Use aio_config.json value: $aioConfigName (if cluster is already Arc-enabled with this name)" -ForegroundColor Gray
        Write-Host "  [3] Abort and fix the configuration files" -ForegroundColor Gray
        Write-Host ""
        
        $choice = Read-Host "Enter choice (1/2/3)"
        
        switch ($choice) {
            "1" {
                $script:ClusterName = $clusterInfoName
                Write-InfoLog "Using cluster name from cluster_info.json: $clusterInfoName"
                Write-WarnLog "Consider updating aio_config.json to match: cluster_name = '$clusterInfoName'"
            }
            "2" {
                $script:ClusterName = $aioConfigName
                Write-InfoLog "Using cluster name from aio_config.json: $aioConfigName"
                Write-WarnLog "Consider updating cluster_info.json if this is a fresh install"
            }
            "3" {
                Write-Host ""
                Write-Host "To fix this, update one of the files to match:" -ForegroundColor Yellow
                Write-Host "  - Edit config/aio_config.json and set cluster_name to '$clusterInfoName'" -ForegroundColor Gray
                Write-Host "  - Or edit config/cluster_info.json and set cluster_name to '$aioConfigName'" -ForegroundColor Gray
                Write-Host ""
                Write-ErrorLog "Configuration mismatch - user chose to abort" -Fatal
            }
            default {
                Write-ErrorLog "Invalid choice. Aborting." -Fatal
            }
        }
    } else {
        Write-Success "Cluster names match: $clusterInfoName"
        $script:ClusterName = $clusterInfoName
    }
}

# ============================================================================
# AZURE AUTHENTICATION
# ============================================================================

function Connect-ToAzure {
    Write-Log "Checking Azure authentication..."
    
    # Check if already logged in
    try {
        $currentAccount = az account show 2>$null | ConvertFrom-Json
        if ($currentAccount) {
            Write-Success "Already logged in as: $($currentAccount.user.name)"
            Write-InfoLog "Subscription: $($currentAccount.name)"
        }
    } catch {
        Write-Log "Not currently logged into Azure. Initiating login..."
        
        if ($DryRun) {
            Write-InfoLog "[DRY-RUN] Would execute: az login"
            return
        }
        
        az login
        $currentAccount = az account show | ConvertFrom-Json
    }
    
    # Set subscription if specified
    if ($script:SubscriptionId) {
        $currentSubId = $currentAccount.id
        if ($script:SubscriptionId -ne $currentSubId) {
            Write-Log "Setting subscription to: $script:SubscriptionId"
            
            if (-not $DryRun) {
                az account set --subscription $script:SubscriptionId
            }
        }
    }
    
    # Get final subscription details
    $currentAccount = az account show | ConvertFrom-Json
    $script:SubscriptionId = $currentAccount.id
    $script:SubscriptionName = $currentAccount.name
    
    # Prompt for missing configuration values
    if (-not $script:ResourceGroup) {
        Write-Host ""
        $script:ResourceGroup = Read-Host "Enter resource group name (will be created if it doesn't exist)"
    }
    
    if (-not $script:Location) {
        Write-Host ""
        $script:Location = Read-Host "Enter Azure region (e.g., eastus, westus2, westeurope)"
    }
    
    if (-not $script:NamespaceName) {
        $script:NamespaceName = "$($script:ClusterName)-ns"
        Write-InfoLog "Using default namespace name: $script:NamespaceName"
    }
    
    # Generate resource names if not provided
    $clusterNameClean = $script:ClusterName.ToLower() -replace '[^a-z0-9]', ''
    
    if (-not $script:StorageAccountName) {
        $script:StorageAccountName = ($clusterNameClean + "storage").Substring(0, [Math]::Min(24, ($clusterNameClean + "storage").Length))
        Write-InfoLog "Using auto-generated storage account name: $script:StorageAccountName"
    }
    
    if (-not $script:SchemaRegistryName) {
        $script:SchemaRegistryName = "$($script:ClusterName)-schema-registry"
        Write-InfoLog "Using auto-generated schema registry name: $script:SchemaRegistryName"
    }
    
    if (-not $script:KeyVaultName) {
        $randomSuffix = -join ((48..57) + (97..122) | Get-Random -Count 4 | ForEach-Object { [char]$_ })
        $script:KeyVaultName = ($clusterNameClean + "kv" + $randomSuffix).Substring(0, [Math]::Min(24, ($clusterNameClean + "kv" + $randomSuffix).Length))
        Write-InfoLog "Using auto-generated Key Vault name: $script:KeyVaultName"
    }
    
    Write-Host ""
    Write-Host "Azure Configuration:" -ForegroundColor Cyan
    Write-Host "  Subscription: $script:SubscriptionName" -ForegroundColor Gray
    Write-Host "  Subscription ID: $script:SubscriptionId" -ForegroundColor Gray
    Write-Host "  Resource Group: $script:ResourceGroup" -ForegroundColor Gray
    Write-Host "  Location: $script:Location" -ForegroundColor Gray
    Write-Host "  Cluster Name: $script:ClusterName" -ForegroundColor Gray
    Write-Host "  Namespace: $script:NamespaceName" -ForegroundColor Gray
    Write-Host "  Storage Account: $script:StorageAccountName" -ForegroundColor Gray
    Write-Host "  Schema Registry: $script:SchemaRegistryName" -ForegroundColor Gray
    Write-Host "  Key Vault: $script:KeyVaultName" -ForegroundColor Gray
    Write-Host ""
    
    Write-Success "Azure authentication configured"
}

# ============================================================================
# ARM TEMPLATE DEPLOYMENT
# ============================================================================

function Deploy-ARMTemplate {
    param(
        [Parameter(Mandatory=$true)]
        [string]$TemplateName,
        
        [Parameter(Mandatory=$true)]
        [hashtable]$Parameters,
        
        [Parameter(Mandatory=$false)]
        [string]$DeploymentName = "",
        
        [Parameter(Mandatory=$false)]
        [switch]$SubscriptionLevel
    )
    
    $templatePath = Join-Path $script:ArmTemplatesDir "$TemplateName.json"
    
    if (-not (Test-Path $templatePath)) {
        Write-ErrorLog "ARM template not found: $templatePath"
        return $null
    }
    
    if (-not $DeploymentName) {
        $DeploymentName = "$TemplateName-$(Get-Date -Format 'yyyyMMddHHmmss')"
    }
    
    # Build parameters as individual arguments (avoid JSON parsing issues)
    $paramArgs = @()
    foreach ($param in $Parameters.GetEnumerator()) {
        $paramArgs += "$($param.Key)=$($param.Value)"
    }
    
    Write-Log "Deploying ARM template: $TemplateName"
    Write-InfoLog "Parameters: $($paramArgs -join ', ')"
    
    if ($DryRun) {
        # Use what-if for validation
        if ($SubscriptionLevel) {
            Write-InfoLog "[DRY-RUN] Validating subscription-level deployment..."
            $result = & az deployment sub what-if `
                --location $script:Location `
                --template-file $templatePath `
                --parameters @paramArgs `
                --output json 2>&1
        } else {
            Write-InfoLog "[DRY-RUN] Validating resource group deployment..."
            $result = & az deployment group what-if `
                --resource-group $script:ResourceGroup `
                --template-file $templatePath `
                --parameters @paramArgs `
                --output json 2>&1
        }
        
        if ($LASTEXITCODE -eq 0) {
            Write-Success "[DRY-RUN] Template validation passed: $TemplateName"
            return @{ success = $true; dryRun = $true }
        } else {
            Write-ErrorLog "[DRY-RUN] Template validation failed: $result"
            return @{ success = $false; error = $result }
        }
    }
    
    # Actual deployment
    if ($SubscriptionLevel) {
        $result = & az deployment sub create `
            --location $script:Location `
            --name $DeploymentName `
            --template-file $templatePath `
            --parameters @paramArgs `
            --output json 2>&1
    } else {
        $result = & az deployment group create `
            --resource-group $script:ResourceGroup `
            --name $DeploymentName `
            --template-file $templatePath `
            --parameters @paramArgs `
            --output json 2>&1
    }
    
    if ($LASTEXITCODE -eq 0) {
        try {
            $deploymentResult = $result | ConvertFrom-Json
            Write-Success "ARM deployment completed: $TemplateName"
            $script:DeployedResources += "$TemplateName"
            return $deploymentResult
        } catch {
            Write-Success "ARM deployment completed: $TemplateName (output parsing skipped)"
            $script:DeployedResources += "$TemplateName"
            return @{ success = $true }
        }
    } else {
        Write-ErrorLog "ARM deployment failed: $TemplateName"
        Write-ErrorLog "Error: $result"
        Write-Host ""
        Write-Host "Stopping deployment due to ARM template failure." -ForegroundColor Red
        
        # Check for authorization error and provide specific guidance
        if ($result -match "roleAssignments/write") {
            Write-Host ""
            Write-Host "============================================================================" -ForegroundColor Yellow
            Write-Host "ROLE ASSIGNMENT PERMISSION ERROR" -ForegroundColor Yellow
            Write-Host "============================================================================" -ForegroundColor Yellow
            Write-Host ""
            Write-Host "Your account cannot create role assignments (RBAC permissions)." -ForegroundColor Yellow
            Write-Host "This is needed to grant the Schema Registry access to the Storage Account." -ForegroundColor Yellow
            Write-Host ""
            Write-Host "To fix this, run the grant_entra_id_roles.ps1 script:" -ForegroundColor Cyan
            Write-Host ""
            Write-Host "  .\grant_entra_id_roles.ps1" -ForegroundColor Green
            Write-Host ""
            Write-Host "NOTE: If you already ran grant_entra_id_roles.ps1 before, you may need to" -ForegroundColor Magenta
            Write-Host "run it AGAIN. Some resources (like Schema Registry) didn't exist yet," -ForegroundColor Magenta
            Write-Host "so the script couldn't grant their role assignments the first time." -ForegroundColor Magenta
            Write-Host ""
            Write-Host "This script grants 'Role Based Access Control Administrator' (resource group" -ForegroundColor Gray
            Write-Host "scope only) which allows you to create role assignments." -ForegroundColor Gray
            Write-Host ""
            Write-Host "After running grant_entra_id_roles.ps1, run this script again." -ForegroundColor Yellow
            Write-Host "============================================================================" -ForegroundColor Yellow
        } elseif ($result -match "AuthorizationFailed|does not have authorization") {
            Write-Host ""
            Write-Host "============================================================================" -ForegroundColor Yellow
            Write-Host "AUTHORIZATION ERROR DETECTED" -ForegroundColor Yellow
            Write-Host "============================================================================" -ForegroundColor Yellow
            Write-Host ""
            Write-Host "Your account does not have sufficient permissions to deploy ARM templates." -ForegroundColor Yellow
            Write-Host "You need 'Contributor' or 'Owner' role on the subscription." -ForegroundColor Yellow
            Write-Host ""
            Write-Host "To grant the required permissions, run:" -ForegroundColor Cyan
            Write-Host ""
            Write-Host "  .\grant_entra_id_roles.ps1" -ForegroundColor Green
            Write-Host ""
            Write-Host "Or ask your Azure admin to grant you one of these roles:" -ForegroundColor Gray
            Write-Host "  - Contributor (can deploy resources)" -ForegroundColor Gray
            Write-Host "  - Owner (can deploy resources and manage access)" -ForegroundColor Gray
            Write-Host ""
            Write-Host "After permissions are granted, run this script again." -ForegroundColor Yellow
            Write-Host "============================================================================" -ForegroundColor Yellow
        } else {
            Write-Host "Please fix the issue above and run the script again." -ForegroundColor Yellow
            Write-Host "Tip: You can use -SkipArcEnable if infrastructure is already deployed." -ForegroundColor Gray
        }
        
        Write-ErrorLog "ARM deployment failed - cannot continue" -Fatal
    }
}

# ============================================================================
# INFRASTRUCTURE DEPLOYMENT
# ============================================================================

function Deploy-Infrastructure {
    Write-Log "Deploying Azure infrastructure via ARM templates..."
    
    # Step 1: Create Resource Group (check if exists first to minimize permission requirements)
    Write-Log "Step 1/6: Checking resource group..."
    
    $rgExists = az group exists --name $script:ResourceGroup 2>$null
    if ($rgExists -eq "true") {
        Write-Success "Resource group already exists: $script:ResourceGroup"
    } else {
        Write-Log "Resource group does not exist, creating via Azure CLI..."
        
        if ($DryRun) {
            Write-InfoLog "[DRY-RUN] Would create resource group: $script:ResourceGroup in $script:Location"
        } else {
            # Use az group create instead of ARM template - requires fewer permissions
            $rgResult = az group create `
                --name $script:ResourceGroup `
                --location $script:Location `
                --tags project=azure-iot-operations cluster=$script:ClusterName `
                --output json 2>&1
            
            if ($LASTEXITCODE -eq 0) {
                Write-Success "Resource group created: $script:ResourceGroup"
                $script:DeployedResources += "ResourceGroup:$script:ResourceGroup"
            } else {
                Write-ErrorLog "Failed to create resource group"
                Write-ErrorLog "Error: $rgResult"
                Write-Host ""
                Write-Host "You may need 'Contributor' role at the subscription level to create resource groups." -ForegroundColor Yellow
                Write-Host "Alternatively, ask your Azure admin to create the resource group for you:" -ForegroundColor Gray
                Write-Host "  az group create --name $script:ResourceGroup --location $script:Location" -ForegroundColor Cyan
                Write-Host ""
                Write-ErrorLog "Cannot continue without resource group" -Fatal
            }
        }
    }
    
    # Step 2: Create Storage Account
    Write-Log "Step 2/6: Creating storage account..."
    $storageResult = Deploy-ARMTemplate -TemplateName "storageAccount" -Parameters @{
        storageAccountName = $script:StorageAccountName
        location = $script:Location
    }
    
    # Step 3: Create Key Vault
    Write-Log "Step 3/6: Creating Key Vault..."
    $kvResult = Deploy-ARMTemplate -TemplateName "keyVault" -Parameters @{
        keyVaultName = $script:KeyVaultName
        location = $script:Location
    }
    
    # Step 4: Create Device Registry Namespace
    Write-Log "Step 4/6: Creating Device Registry namespace..."
    $nsResult = Deploy-ARMTemplate -TemplateName "deviceRegistryNamespace" -Parameters @{
        namespaceName = $script:NamespaceName
        location = $script:Location
    }
    
    # Step 5: Create Schema Registry
    Write-Log "Step 5/6: Creating Schema Registry..."
    $srResult = Deploy-ARMTemplate -TemplateName "schemaRegistry" -Parameters @{
        schemaRegistryName = $script:SchemaRegistryName
        location = $script:Location
        storageAccountName = $script:StorageAccountName
    }
    
    # Step 6: Create Managed Identity for secret sync
    Write-Log "Step 6/6: Creating Managed Identity..."
    $miName = "$($script:ClusterName)-secretsync-mi"
    $miResult = Deploy-ARMTemplate -TemplateName "managedIdentity" -Parameters @{
        managedIdentityName = $miName
        location = $script:Location
    }
    
    # Assign roles (requires principal IDs from previous deployments)
    if (-not $DryRun) {
        Write-Log "Configuring role assignments..."
        
        # Get schema registry principal ID
        $srPrincipalId = az resource show `
            --resource-group $script:ResourceGroup `
            --resource-type "Microsoft.DeviceRegistry/schemaRegistries" `
            --name $script:SchemaRegistryName `
            --query "identity.principalId" -o tsv 2>$null
        
        if ($srPrincipalId) {
            Write-InfoLog "Assigning Storage Blob Data Contributor to schema registry..."
            Deploy-ARMTemplate -TemplateName "storageRoleAssignment" -Parameters @{
                storageAccountName = $script:StorageAccountName
                principalId = $srPrincipalId
            }
        }
        
        # Get managed identity principal ID
        $miPrincipalId = az identity show `
            --name $miName `
            --resource-group $script:ResourceGroup `
            --query "principalId" -o tsv 2>$null
        
        if ($miPrincipalId) {
            Write-InfoLog "Assigning Key Vault Secrets User to managed identity..."
            Deploy-ARMTemplate -TemplateName "keyVaultRoleAssignment" -Parameters @{
                keyVaultName = $script:KeyVaultName
                principalId = $miPrincipalId
            }
        }
    }
    
    Write-Success "Infrastructure deployment completed"
}

# ============================================================================
# ARC ENABLEMENT (Requires Azure CLI - no ARM template available)
# ============================================================================

function Enable-ArcForCluster {
    if ($SkipArcEnable) {
        Write-InfoLog "Skipping Arc enablement (-SkipArcEnable flag)"
        return
    }
    
    Write-Log "Connecting cluster to Azure Arc..."
    Write-InfoLog "Note: Arc enablement requires Azure CLI (no ARM template available)"
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Would execute: az connectedk8s connect"
        return
    }
    
    # Check if cluster is already Arc-enabled
    $arcCluster = az connectedk8s show --name $script:ClusterName --resource-group $script:ResourceGroup 2>$null
    
    if ($arcCluster) {
        Write-Success "Cluster $script:ClusterName is already Arc-enabled"
    } else {
        Write-Log "Connecting cluster to Azure Arc..."
        Write-InfoLog "This command must have access to the cluster via kubeconfig"
        Write-InfoLog "If running remotely, ensure KUBECONFIG is set or use --kube-config parameter"
        
        # Check if kubeconfig is available
        $kubeConfig = $null
        if ($script:ClusterData.kubeconfig_base64) {
            # Decode and save kubeconfig temporarily
            $kubeconfigBytes = [System.Convert]::FromBase64String($script:ClusterData.kubeconfig_base64)
            $kubeconfigContent = [System.Text.Encoding]::UTF8.GetString($kubeconfigBytes)
            
            # Update server address if it's localhost
            if ($kubeconfigContent -match 'server:\s*https?://127\.0\.0\.1:') {
                if ($script:ClusterData.node_ip) {
                    $kubeconfigContent = $kubeconfigContent -replace 'server:\s*https?://127\.0\.0\.1:', "server: https://$($script:ClusterData.node_ip):"
                    Write-InfoLog "Updated kubeconfig to use node IP: $($script:ClusterData.node_ip)"
                }
            }
            
            $kubeConfig = Join-Path $env:TEMP "kubeconfig_$($script:ClusterName).yaml"
            Set-Content -Path $kubeConfig -Value $kubeconfigContent -NoNewline
            Write-InfoLog "Using kubeconfig from cluster_info.json"
        }
        
        if ($kubeConfig) {
            $env:KUBECONFIG = $kubeConfig
            az connectedk8s connect --name $script:ClusterName --resource-group $script:ResourceGroup
        } else {
            Write-WarnLog "No kubeconfig found in cluster_info.json"
            Write-Host ""
            Write-Host "To Arc-enable the cluster, you need kubectl access." -ForegroundColor Yellow
            Write-Host "Options:" -ForegroundColor Cyan
            Write-Host "  1. Run this script ON the edge device with kubectl access" -ForegroundColor Gray
            Write-Host "  2. Set KUBECONFIG environment variable before running" -ForegroundColor Gray
            Write-Host "  3. Run on edge device:" -ForegroundColor Gray
            Write-Host "     az connectedk8s connect --name $($script:ClusterName) --resource-group $($script:ResourceGroup)" -ForegroundColor Yellow
            Write-Host ""
            
            $continue = Read-Host "Do you have kubectl access on this machine? (y/N)"
            if ($continue -eq 'y' -or $continue -eq 'Y') {
                az connectedk8s connect --name $script:ClusterName --resource-group $script:ResourceGroup
            } else {
                Write-WarnLog "Skipping Arc enablement - run manually on edge device"
                return
            }
        }
        
        if ($LASTEXITCODE -ne 0) {
            Write-ErrorLog "Failed to Arc-enable cluster"
            Write-Host "This may need to be run on the edge device with kubectl access." -ForegroundColor Yellow
            return
        }
        
        Write-Success "Cluster Arc-enabled successfully"
        $script:DeployedResources += "ConnectedCluster:$script:ClusterName"
    }
    
    # Enable custom locations
    Write-Log "Enabling custom locations and cluster connect features..."
    $objectId = az ad sp show --id bc313c14-388c-4e7d-a58e-70017303ee3b --query id -o tsv 2>$null
    
    if ($objectId) {
        az connectedk8s enable-features `
            --name $script:ClusterName `
            --resource-group $script:ResourceGroup `
            --custom-locations-oid $objectId `
            --features cluster-connect custom-locations 2>$null
        
        Write-Success "Custom locations enabled"
    }
    
    # Enable OIDC issuer and workload identity
    Write-Log "Enabling OIDC issuer and workload identity..."
    az connectedk8s update `
        --name $script:ClusterName `
        --resource-group $script:ResourceGroup `
        --enable-oidc-issuer `
        --enable-workload-identity 2>$null
    
    Write-Success "OIDC and workload identity enabled"
}

# ============================================================================
# IOT OPERATIONS DEPLOYMENT (Requires Azure CLI)
# ============================================================================

function Deploy-IoTOperations {
    if ($SkipIoTOps) {
        Write-InfoLog "Skipping IoT Operations deployment (-SkipIoTOps flag)"
        return
    }
    
    Write-Log "Deploying Azure IoT Operations..."
    Write-InfoLog "Note: IoT Operations deployment requires Azure CLI (no ARM template available)"
    
    # Enable UTF-8 encoding
    [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
    $env:PYTHONIOENCODING = "utf-8"
    $env:PYTHONUTF8 = "1"
    chcp 65001 2>&1 | Out-Null
    
    $instanceName = "$script:ClusterName-aio"
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Would deploy Azure IoT Operations instance: $instanceName"
        Write-InfoLog "[DRY-RUN] az iot ops init --cluster $script:ClusterName --resource-group $script:ResourceGroup"
        Write-InfoLog "[DRY-RUN] az iot ops create --cluster $script:ClusterName --resource-group $script:ResourceGroup --name $instanceName"
        return
    }
    
    # Check if already deployed
    $existingInstance = az iot ops show --name $instanceName --resource-group $script:ResourceGroup 2>&1
    
    if ($LASTEXITCODE -eq 0) {
        Write-Success "Azure IoT Operations instance $instanceName already exists"
        return
    }
    
    # Check Arc cluster connectivity
    Write-Log "Checking Arc cluster connectivity..."
    $clusterStatus = az connectedk8s show `
        --name $script:ClusterName `
        --resource-group $script:ResourceGroup `
        --query "connectivityStatus" -o tsv 2>$null
    
    if ($clusterStatus -ne "Connected") {
        Write-ErrorLog "Arc cluster is not connected (status: $clusterStatus)"
        Write-Host ""
        Write-Host "The cluster needs to be fully connected before IoT Operations can be deployed." -ForegroundColor Yellow
        Write-Host "Wait a few minutes and check: az connectedk8s show --name $script:ClusterName --resource-group $script:ResourceGroup --query connectivityStatus" -ForegroundColor Gray
        Write-Host ""
        return
    }
    
    Write-Success "Arc cluster status: Connected"
    
    # Initialize cluster
    Write-Log "Initializing cluster for Azure IoT Operations..."
    az iot ops init --cluster $script:ClusterName --resource-group $script:ResourceGroup
    
    # Get schema registry ID
    $schemaRegistryId = az resource show `
        --resource-group $script:ResourceGroup `
        --resource-type "Microsoft.DeviceRegistry/schemaRegistries" `
        --name $script:SchemaRegistryName `
        --query "id" -o tsv 2>$null
    
    # Get namespace ID
    $namespaceId = "/subscriptions/$script:SubscriptionId/resourceGroups/$script:ResourceGroup/providers/Microsoft.DeviceRegistry/namespaces/$script:NamespaceName"
    
    Write-Log "Deploying Azure IoT Operations instance..."
    Write-InfoLog "This may take several minutes..."
    
    az iot ops create `
        --cluster $script:ClusterName `
        --resource-group $script:ResourceGroup `
        --name $instanceName `
        --sr-resource-id $schemaRegistryId `
        --ns-resource-id $namespaceId `
        --no-progress 2>&1
    
    if ($LASTEXITCODE -ne 0) {
        Write-ErrorLog "Azure IoT Operations deployment failed"
        return
    }
    
    Write-Success "Azure IoT Operations deployed: $instanceName"
    $script:DeployedResources += "IoTOperationsInstance:$instanceName"
    
    # Enable secret sync
    Write-Log "Enabling secret sync..."
    $miName = "$($script:ClusterName)-secretsync-mi"
    $miResourceId = az identity show `
        --name $miName `
        --resource-group $script:ResourceGroup `
        --query "id" -o tsv 2>$null
    
    if ($miResourceId) {
        az iot ops secretsync enable `
            --name $instanceName `
            --resource-group $script:ResourceGroup `
            --mi-user-assigned $miResourceId `
            --kv-resource-id "/subscriptions/$script:SubscriptionId/resourceGroups/$script:ResourceGroup/providers/Microsoft.KeyVault/vaults/$script:KeyVaultName" 2>$null
        
        Write-Success "Secret sync enabled"
    }
}

# ============================================================================
# VERIFICATION
# ============================================================================

function Test-Deployment {
    if ($SkipVerification) {
        Write-InfoLog "Skipping verification (-SkipVerification flag)"
        return
    }
    
    if ($DryRun) {
        Write-InfoLog "[DRY-RUN] Skipping verification in dry-run mode"
        return
    }
    
    Write-Log "Verifying deployment..."
    
    # Verify resource group
    $rgExists = az group exists --name $script:ResourceGroup 2>$null
    if ($rgExists -eq "true") {
        Write-Success "Resource group verified: $script:ResourceGroup"
    } else {
        Write-WarnLog "Resource group not found: $script:ResourceGroup"
    }
    
    # Verify storage account
    $storage = az storage account show --name $script:StorageAccountName --resource-group $script:ResourceGroup 2>$null
    if ($storage) {
        Write-Success "Storage account verified: $script:StorageAccountName"
    } else {
        Write-WarnLog "Storage account not found: $script:StorageAccountName"
    }
    
    # Verify Key Vault
    $kv = az keyvault show --name $script:KeyVaultName --resource-group $script:ResourceGroup 2>$null
    if ($kv) {
        Write-Success "Key Vault verified: $script:KeyVaultName"
    } else {
        Write-WarnLog "Key Vault not found: $script:KeyVaultName"
    }
    
    # Verify Arc cluster
    $arc = az connectedk8s show --name $script:ClusterName --resource-group $script:ResourceGroup 2>$null
    if ($arc) {
        $arcData = $arc | ConvertFrom-Json
        Write-Success "Arc cluster verified: $script:ClusterName (Status: $($arcData.connectivityStatus))"
    } else {
        Write-WarnLog "Arc cluster not found: $script:ClusterName"
    }
    
    # Verify IoT Operations
    $instanceName = "$script:ClusterName-aio"
    $iotOps = az iot ops show --name $instanceName --resource-group $script:ResourceGroup 2>$null
    if ($iotOps) {
        $iotOpsData = $iotOps | ConvertFrom-Json
        Write-Success "IoT Operations verified: $instanceName (State: $($iotOpsData.provisioningState))"
    } else {
        Write-WarnLog "IoT Operations not found: $instanceName"
    }
    
    Write-Success "Verification completed"
}

# ============================================================================
# DEPLOYMENT SUMMARY
# ============================================================================

function Export-DeploymentSummary {
    Write-Log "Generating deployment summary..."
    
    $summary = @{
        deployment_timestamp = (Get-Date).ToString("o")
        subscription_id = $script:SubscriptionId
        subscription_name = $script:SubscriptionName
        resource_group = $script:ResourceGroup
        location = $script:Location
        cluster_name = $script:ClusterName
        iot_operations_instance = "$script:ClusterName-aio"
        storage_account = $script:StorageAccountName
        schema_registry = $script:SchemaRegistryName
        key_vault = $script:KeyVaultName
        namespace = $script:NamespaceName
        deployed_resources = $script:DeployedResources
        errors = $script:Errors
        dry_run = $DryRun.IsPresent
    }
    
    $summary | ConvertTo-Json -Depth 10 | Set-Content -Path $script:DeploymentSummaryFile
    
    Write-Success "Deployment summary saved to: $script:DeploymentSummaryFile"
}

function Show-CompletionSummary {
    Write-Host ""
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host "Azure IoT Operations Configuration Completed!" -ForegroundColor Cyan
    Write-Host "============================================================================" -ForegroundColor Cyan
    Write-Host ""
    
    if ($DryRun) {
        Write-Host "DRY-RUN MODE - No changes were made" -ForegroundColor Yellow
        Write-Host ""
    }
    
    Write-Host "Deployed Resources:" -ForegroundColor Green
    foreach ($resource in $script:DeployedResources) {
        Write-Host "  - $resource" -ForegroundColor Gray
    }
    Write-Host ""
    
    if ($script:Errors.Count -gt 0) {
        Write-Host "Errors encountered:" -ForegroundColor Red
        foreach ($error in $script:Errors) {
            Write-Host "  - $error" -ForegroundColor Red
        }
        Write-Host ""
    }
    
    Write-Host "Azure Resources:" -ForegroundColor Cyan
    Write-Host "  Subscription: $script:SubscriptionName" -ForegroundColor Gray
    Write-Host "  Resource Group: $script:ResourceGroup" -ForegroundColor Gray
    Write-Host "  Location: $script:Location" -ForegroundColor Gray
    Write-Host "  Cluster: $script:ClusterName" -ForegroundColor Gray
    Write-Host "  IoT Operations: $($script:ClusterName)-aio" -ForegroundColor Gray
    Write-Host "  Key Vault: $script:KeyVaultName" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "Azure Portal:" -ForegroundColor Cyan
    Write-Host "  https://portal.azure.com/#@/resource/subscriptions/$script:SubscriptionId/resourceGroups/$script:ResourceGroup" -ForegroundColor Gray
    Write-Host ""
    
    Write-Host "Next Steps:" -ForegroundColor Green
    Write-Host "  1. Review deployment summary: $script:DeploymentSummaryFile" -ForegroundColor Gray
    Write-Host "  2. Add secrets to Key Vault for Fabric RTI dataflows" -ForegroundColor Gray
    Write-Host "  3. Deploy edge modules using Deploy-EdgeModules.ps1" -ForegroundColor Gray
    Write-Host "  4. Configure Fabric dataflows using Deploy-FabricDataflows.ps1" -ForegroundColor Gray
    Write-Host ""
    Write-Host "============================================================================" -ForegroundColor Cyan
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

function Main {
    try {
        Initialize-Logging
        
        Test-Prerequisites
        
        Import-ClusterInfo
        Import-AzureConfig
        
        # Validate cluster names match between config files
        Test-ConfigConsistency
        
        Connect-ToAzure
        
        # Deploy infrastructure via ARM templates
        Deploy-Infrastructure
        
        # Arc enablement and IoT Operations (CLI-based)
        Enable-ArcForCluster
        Deploy-IoTOperations
        
        # Verification
        Test-Deployment
        
        # Summary
        Export-DeploymentSummary
        Show-CompletionSummary
        
    } catch {
        Write-ErrorLog "Unexpected error: $_"
        Write-Host ""
        Write-Host "Stack trace:" -ForegroundColor Red
        Write-Host $_.ScriptStackTrace -ForegroundColor Red
        throw
    } finally {
        Stop-Transcript
    }
}

# Run main function
Main
